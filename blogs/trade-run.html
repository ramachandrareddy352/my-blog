<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>acount-abstraction</title>
    <meta content="" name="description">
    <meta content="" name="keywords">

    <!-- Favicons -->
    <link href="../assets/img/favicon.jpg" rel="icon">
    <link href="../assets/img/apple-touch-icon.png" rel="apple-touch-icon">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i"
        rel="stylesheet">
    <script src="https://kit.fontawesome.com/67ced9e5a8.js" crossorigin="anonymous"></script>


    <!-- Vendor CSS Files -->
    <link href="../assets/vendor/aos/aos.css" rel="stylesheet">
    <link href="../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
    <link href="../assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
    <link href="../assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
    <link href="../assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

    <!-- Template Main CSS File -->
    <link href="../assets/css/style.css" rel="stylesheet">
    <link href="./css/blogStyle.css" rel="stylesheet">

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tomorrow-night-blue.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script> -->

    <script>hljs.highlightAll();</script>

</head>

<body>
    <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

    <!-- ======= Header ======= -->
    <header id="header">
        <div class="d-flex flex-column">

            <div class="profile">
                <img src="../assets/img/profile-img.jpg" alt="" class="img-fluid rounded-circle">
                <center>
                    <h4 class="text-light">@rama_eth</h4>
                </center>
                <div class="social-links mt-3 text-center">
                    <a href="https://twitter.com/TavanamRama" class="twitter" target="_blank"><i
                            class="bx bxl-twitter"></i></a>
                    <a href="https://github.com/ramachandrareddy352" class="instagram" target="_blank"><i
                            class="bx bxl-github"></i></a>
                    <a href="https://www.instagram.com/rama_chandra_reddy_tavanam/" class="instagram" target="_blank"><i
                            class="bx bxl-instagram"></i></a>
                    <a href="https://www.linkedin.com/in/ramachandratavanam/" class="linkedin" target="_blank"><i
                            class="bx bxl-linkedin"></i></a>
                </div>
            </div>

            <nav id="navbar" class="nav-menu navbar">
                <ul>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-home"></i>
                            <span>Home</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-user"></i>
                            <span>About</span></a>
                    </li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-file-blank"></i>
                            <span>Resume</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-share-alt"></i>
                            <span>Portfolio</span></a></li>
                    <li><a href="../index.html#blogs" class="nav-link scrollto active"><i
                                class="bx bx-book-content"></i>
                            <span>Blogs/Trade-Run</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-server"></i>
                            <span>Services</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-envelope"></i>
                            <span>Contact</span></a></li>
                </ul>
            </nav>
            <!-- .nav-menu -->
        </div>
    </header>

    <main id="main">

        <!-- ======= Blog data Section ======= -->
        <div class="container" id="blog">

            <!-- Introduction -->
            <div>
                <h3> >> Trade Run</h3>
                <p>Hello WEB3, The project is a decentralized exchange (DEX) designed for trading futures and perpetual
                    contracts with up to 10x leverage, offering users a seamless way to speculate on asset price
                    movements without holding the underlying assets. Traders can access up to 10x leverage, allowing
                    them to amplify their positions and potentially increase profits (or losses). This feature caters to
                    more experienced traders looking to capitalize on price volatility in a highly efficient and
                    capital-efficient way.
                </p>
                <p>
                    It is completely a Decentralized
                    Autonomous Organization. Goverenece tokens can
                    be get in different ways(Merkle Airdrops, Staking LP tokens, Direct buying tokens and Other DEX, CEX
                    platforms). Tokens holders can make proposals who are having minimum proposal threashold amount to
                    make propoasl and done voting and make updates to protocol.
                </p>
                <span>Clone the repo : </span>
                <div class="repo">
                    <span>$ git clone <a href="https://github.com/ramachandrareddy352/trade-run/"
                            target="_blank">https://github.com/ramachandrareddy352/trade-run/</a></span><br>
                    <span>$ cd trade-run</span><br>
                    <span>$ yarn install</span>
                </div>
            </div>

            <div>
                <br>
                <div style="display: flex; justify-content: space-between;">
                    <img src="./blog-images/trade-run/trade-run-logo.png" width="300px" height="250px">
                    <img src="./blog-images/trade-run/perpetuals.png" width="300px" height="250px">
                </div>
                <br>
                <div style="display: flex; justify-content: space-between;">
                    <img src="./blog-images/trade-run/futures.png" width="300px" height="250px">
                    <img src="./blog-images/trade-run/airdrop.png" width="300px" height="250px">
                </div>
                <br>
                <div style="display: flex; justify-content: space-between;">
                    <img src="./blog-images/trade-run/buytokens.png" width="300px" height="250px">
                    <img src="./blog-images/trade-run/staking.png" width="300px" height="250px">
                </div>
            </div>

            <div>
                <hr>
                <h3>>> Files Structure</h3>
                <ul>
                    <li>futures</li>
                    <ul>
                        <li>FuturesTrading.sol</li>
                    </ul>
                    <li>goverence</li>
                    <ul>
                        <li>GoverenceToken.sol</li>
                        <li>GoverenerContract.sol</li>
                        <li>Timelock.sol</li>
                    </ul>
                    <li>interface</li>
                    <ul>
                        <li>AggregatorV3Interface.sol</li>
                        <li>AutomationCompatibleInterface.sol</li>
                        <li>IHookManager</li>
                        <li>ILPToken</li>
                    </ul>
                    <li>library</li>
                    <ul>
                        <li>PoolLibrary.sol</li>
                    </ul>
                    <li>perpetuals.sol</li>
                    <uL>
                        <li>Factory.sol</li>
                        <li>PositionDataTypes.sol</li>
                        <li>TradePool.sol</li>
                        <li>TradeRunERC20.sol</li>
                    </uL>
                    <li>rewards</li>
                    <ul>
                        <li>MerkleAirdrop.sol</li>
                        <li>Presale.sol</li>
                        <li>StakingPool</li>
                    </ul>
                    <li>utils</li>
                    <ul>
                        <li>Multicall.sol</li>
                        <li>MultiSigWallet.sol</li>
                        <li>SignatureSplitter.sol</li>
                    </ul>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Goverence Tokens</h3>
                <h5>>> Key Features</h5>
                <ul>
                    <li>Governance tokens represent ownership or voting power in this protocol.</li>
                    <li>It is build using Openzeppelin ERC20 Votes contract.</li>
                    <li>Holders of these tokens have the right to participate in the decision-making process,
                        influencing the direction and future development of the project.</li>
                    <li>Holders will make proposals and make voting to update the protocol.</li>
                    <li>User can get the tokens in different ways</li>
                    <ol>
                        <li>Merkle Airdrops</li>
                        <li>Staking Pool LP Tokens</li>
                        <li>Presale</li>
                        <li>DEX & CEX platforms</li>
                    </ol>
                    <li>
                        Goverence Tokens are Maximum supply of 1 Billion. Tokens are minted at initial for different
                        sectors.
                        <ul>
                            <li>presale : 350 Millions Tokens(35%)</li>
                            <li>airdrops : 60 Million Tokens(6%)</li>
                            <li>staking pools : 200 Million Tokens(20%)</li>
                            <li>liquidate into DEX : 130 Million Tokens(13%)</li>
                            <li>CEX : 130 Million Tokens(13%)</li>
                            <li>employees : 100 Million Tokens(10%)</li>
                            <li>future uses : 30 Million Tokens(3%)</li>
                        </ul>
                    </li>
                </ul>
                <h5>>> Key Functions</h5>
                <ul>
                    <li>mintTokens(): Used to mint goverence tokens for futures uses by only owner.</li>
                    <li>delegate(): Token holder can delegate his voting power to other trusted uses to make decisions
                        instead of him.</li>
                    <li>delegateBySig(): Delegate voting power by signature.</li>
                    <li>getVotes(address): Returns the current amount of votes that address has.</li>
                </ul>
                <h5>>> Security considirations</h5>
                <ul>
                    <li>Protect against "flash loan attacks", where an attacker could borrow tokens temporarily to
                        manipulate the outcome of a vote. By implementing Num check points.</li>
                    <li>Using secure openzeppelin smart contracts which is also gas efficient.</li>
                    <li>Implemented a timelock for governance decisions so that any approved changes do not take effect
                        immediately. This provides a window during which the community can review and potentially
                        intervene if a malicious proposal is passed.</li>
                    <li>Fixed total supply cap to 1 Billion tokens.</li>
                    <li>Delegation is secure and resistant to bugs, one address can control through delegation</li>
                    <li>Consider designing tokenomics or governance structures that prevent large holders ("whales")
                        from gaining disproportionate control. Techniques like quadratic voting (which reduces the
                        influence of large holders) can help balance power.</li>
                    <li>Smaller token holders to participate in governance by offering rewards or making voting easier
                        to avoid control being concentrated in a few hands.</li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Merkle Airdrops</h3>
                <p>
                    A Merkle airdrop is a method for distributing tokens to a large number of recipients using a Merkle
                    tree data structure. It optimizes gas costs and simplifies the airdrop process compared to
                    traditional airdrop methods. A Merkle tree is a cryptographic structure where a root hash represents
                    the entire set of data (recipients and amounts in this case) while reducing the need to store or
                    verify large amounts of data on-chain.
                </p>
                <h5>>> Key Functions</h5>
                <ul>
                    <li>createRound(): Owner will create a round to claim airdrops to the users.</li>
                    <li>updateMerkleRoot()</li>
                    <li>updateRoundTime()</li>
                    <li>claimAirdrop(): Claimer call this function to claim airdrop tokens for particular roundId with
                        proofs</li>
                    <li>removeUnclaimedTokens(): If the claim period is over and if there are any tokens remaining in
                        that round are removed and added to ramaining tokens in the contract.</li>
                </ul>
                <h5>>> Security considirations</h5>
                <ul>
                    <li>Implemented safeguards against replay attacks where an attacker tries to reuse an
                        already-processed Merkle proof to claim tokens multiple times.</li>
                    <li>For any attacks, owner can pause the airdrops claiming.</li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Staking Pool</h3>
                <p>Liquidity providers get the LP tokens by investing collateral tokens in the pools. By staking that LP
                    tokens users can get the Goverenec Tokens with 9% APY. If they stake the LP Tokens for locking fixed
                    period they will get more APY that normal.</p>
                <ul>
                    <li>30 Days : 11% APY</li>
                    <li>60 Days : 12% APY</li>
                    <li>90 Days : 13% APY</li>
                    <li>120 Days : 14% APY</li>
                </ul>
                <ul>
                    <li>More the value(price of collateral) of LP token have more the rewards were earned.</li>
                    <li>Only certain tokens allowed to stake in the pool, which are allowed by Factoy contract.</li>
                </ul>
                <h5>>> Key Functions</h5>
                <ul>
                    <li>addStakingToken(): add the LP tokens to allow list(done by factory).</li>
                    <li>fixedStake(): Staked for fixed period of time.</li>
                    <li>stake(): No fixed period is locked, user can unstake his LP tokens at any time.</li>
                    <li>unStakeFixed(): It is claimed after the staking period ended.</li>
                    <li>unStake(): unstake at any time.</li>
                    <li>claimRewards(): claim the goverence tokens as rewards.</li>
                </ul>
                <h5>>> Secuity considerations</h5>
                <ul>
                    <li>Users can stake the LP's by making digital signature also(using permit).</li>
                    <li>Tokens are transfered safely using SafeERC20 library.</li>
                    <li>Rewards are upated before the updations of state variables in the contract.</li>
                    <li>Follows the Checks-Effects-Interactions pattern, which ensures that state changes (e.g.,
                        updating user balances) occur before external calls, mitigating reentrancy risk</li>
                    <li>Price of the tokens is taken from Chainlink pricefeeds using AggregatorV3Interface.</li>
                    <li>The reward distribution logic is resistant to overflow attacks</li>
                    <li>Batch operations also done through Multicall implementations.</li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Buy Tokens</h3>
                <h5>>> Key Featues</h5>
                <ul>
                    <li>Users can buy the goverenec tokens directly from the presale contract(marketplace).</li>
                    <li>The price of
                        goverenec token is changed dynamicaly from 1$ to 25$. If the tokens are solded then the
                        price
                        also
                        increased based on the remaining tokens in the presale.</li>
                    <li>The initial price of token starts from 1$.</li>
                    <li>Only white list collateral is used to buy the tokens.</li>
                </ul>
                <h5>>> Key Functions</h5>
                <ul>
                    <li>getCurrentPrice(): get the price of goverenec token in presale.</li>
                    <li>buyToken(): Buy the tokens using market valued collatererals.</li>
                </ul>
                <h5>>> Security considerations</h5>
                <ul>
                    <li>It implements pausable functions.</li>
                    <li>Allow digital signatuer to approve the tokens to spend.</li>
                    <li>Price of the collateral tokens it taken from the chainlink pricefeed securely.</li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Timelock Controller</h3>
                <p>
                    A Timelock Controller in a Decentralized Autonomous Organization (DAO) is a crucial mechanism that
                    introduces a delay between when a proposal is approved and when it can actually be executed. Its
                    main purpose is to enhance security, transparency, and accountability within the DAO’s
                    decision-making and governance processes.
                </p>
                <h5>>> Key Features & Security Considirations</h5>
                <ul>
                    <li>The timelock ensures that governance decisions, such as contract upgrades, fund transfers, or
                        parameter changes, cannot be executed immediately after approval. This delay gives stakeholders
                        time to review and react to potentially harmful proposals.</li>
                    <li>If malicious actors try to push through harmful changes, the timelock delay provides an
                        opportunity for the DAO community to respond, raise alarms, or take preventative actions (e.g.,
                        withdrawing funds, voting to cancel the proposal).</li>
                    <li>By introducing a delay before actions can be executed, timelocks reduce the power of centralized
                        governance entities or actors who might try to push through proposals without community input or
                        consensus.</li>
                    <li>The timelock adds an additional layer of security, giving multiple signers time to review and
                        approve actions with deliberation.</li>
                    <li>Here we allow proposal role for goverence contract address. </li>
                    <li>If a proposal involves moving treasury funds or distributing rewards, the timelock can prevent
                        sudden large withdrawals or malicious fund transfers, ensuring the DAO’s funds are more secure.
                    </li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Goverence Contract</h3>
                <p>The Governance contract plays a crucial role in Decentralized Autonomous Organizations (DAOs) by
                    providing a secure, flexible, and standardized framework for managing decentralized governance
                    processes. It allows a DAO to operate in a decentralized manner, where decision-making power is
                    distributed among token holders or members of the organization.</p>
                <ul>
                    <li><b>Decentralized Decision-Making</b></li>
                    <ul>
                        <li>
                            The OpenZeppelin Governance contract enables token holders to participate in decision-making
                            processes by voting on proposals.
                        </li>
                        <li>This decentralized approach ensures that decisions are made collectively, without relying on
                            a central authority, in line with the DAO's principles of autonomy and transparency.
                        </li>
                        <li>
                            Proposals can include changes to protocol parameters, upgrades to smart contracts, or
                            decisions on how to allocate funds.
                        </li>
                    </ul>
                    <li><b>On-Chain Proposal Creation and Voting</b></li>
                    <ul>
                        <li>
                            Proposal Creation: DAO members (typically token holders) can create proposals, which are
                            specific actions or changes they want the DAO to implement.
                        </li>
                        <li>Proposals are usually subject to voting, and the community decides whether to approve or
                            reject them.</li>
                        <li>
                            Voting Mechanism: Token holders vote on proposals using their governance tokens. The voting
                            system is flexible, allowing for different types of voting models, such as single-choice,
                            approval, or weighted voting (based on token holdings). OpenZeppelin Governance handles the
                            voting process securely on-chain.</li>
                    </ul>
                    <li><b>Token-Based Voting Power</b></li>
                    <ul>
                        <li>
                            The contract typically assigns voting power based on the number of governance tokens a
                            participant holds. This allows stakeholders with a larger share of tokens to have more
                            influence in the governance process, aligning voting power with economic stake in the
                            system.
                        </li>
                        <li>
                            It supports token-weighted voting, where governance tokens like ERC20 or ERC721 tokens
                            determine the voting power of each member.</li>
                    </ul>
                    <li><b>Quorum and Threshold Management</b></li>
                    <ul>
                        <li>
                            Quorum Requirements: The OpenZeppelin Governance contract allows for setting quorum
                            requirements, which specify the minimum number of votes that must be cast for a proposal to
                            be valid. This ensures that decisions are made with sufficient participation from the
                            community.
                        </li>
                        <li>
                            Voting Thresholds: DAOs can set thresholds for passing a proposal, such as requiring a
                            simple majority, a supermajority, or other custom rules. These thresholds can vary based on
                            the importance of the decision.</li>
                    </ul>
                    <li><b>Timelocks for Security and Transparency</b></li>
                    <ul>
                        <li>
                            The Governance contract can be combined with a Timelock contract, which delays the execution
                            of approved proposals. </li>
                        <li>This delay ensures that the community has time to review the decision and act if a malicious
                            proposal is passed.</li>
                        <li>
                            The timelock provides a safeguard by allowing DAO members to intervene before executing
                            significant changes, like protocol upgrades or large fund transfers.
                        </li>
                    </ul>
                    <li><b>Proposal Execution</b></li>
                    <ul>
                        <li>
                            Once a proposal is approved by the majority of voters (according to predefined rules), the
                            Governance contract can automatically execute the proposal through smart contracts. This
                            execution is decentralized, removing the need for a trusted intermediary.</li>
                        <li>
                            The OpenZeppelin Governance contract integrates tightly with smart contracts to ensure that
                            proposals can trigger actions like updating contract parameters, transferring assets, or
                            upgrading contracts.
                        </li>
                    </ul>
                    <li><b>Flexible Governance Models</b></li>
                    <ul>
                        <li>
                            OpenZeppelin's contracts are modular and flexible, allowing DAOs to customize their
                            governance system based on their specific needs.</li>
                        <li>This includes setting different types of governance rules, such as:</li>
                        <li>
                            Delegated Voting: Token holders can delegate their voting power to other members, enabling
                            those with less time or expertise to still participate indirectly in the decision-making
                            process.</li>
                        <li>
                            Weighted Voting: Proposals may require different voting weights, giving more or less power
                            to certain categories of users, such as founders, early contributors, or core developers.
                        </li>
                    </ul>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Futures</h3>
                <h5>>> Key Features</h5>
                <ul>
                    <li>Any user can sell their token assests for a fixed price upto some expiry date.</li>
                    <li>Buyer can buy the contract directly or hold the contract for that price fto the given expiry
                        date by paying some margin amount to hold the contract.</li>
                    <li>If any seller or buyer break the contract rules seller will loss his 3% of tokens</li>
                    <li>If buyer break the rules 3% of stike price amount is taken from the amount he paid from the
                        margin.</li>
                    <li>To create a contract seller have to pay some fees 0.05% of his assests based on the time
                        difference between the creation and expiration of contract</li>
                    <li>Owner if the Future contract id "TimeLock controller", Updation aer done through voting
                        mechanism.
                    </li>
                    <li>
                        Here we use chainlink "Automation" to close the contracts if the expiration date is met.
                    </li>
                    <li>Seller can update his contract before any buyer bought the contract.</li>
                    <li>Seller can choose which tyoe of tokens(collateral) he have to accepet for payment for contract
                        buying.</li>
                    <li>There are 5 stages for the contract 1)Active 2)
                        Bought 3)
                        Settled 4)
                        Cancelled and 5)
                        Experied</li>
                    <li>Users can approve the tokens by making digital signatures also.</li>
                </ul>
                <h5>>> Key Function</h5>
                <ul>
                    <li>updateSellerFee() : update the seller fees by the timelock controller.</li>
                    <li>updateExpiry() : updating min &max expiry by timelock.</li>
                    <li>updateMargin() : update min & max margins by timelock.</li>
                    <li>updateVoilationFee(): Update voilation fees by timelock.</li>
                    <li>createContract(): Any user can create contract by paying fees to open contract.</li>
                    <li>buyContract() : Function called to buy particular contract by paying margin amount.</li>
                    <li>settleContract(): Paying full amount to settle the contract.</li>
                    <li>cancelContract(): This is called by the seller to cancel his contract.</li>
                    <li>dropContract(): This is called bby the buyer afetr paying the margin amount.</li>
                    <li>expireContract(): This is called by any one, it works only if the passed id has expired time.
                    </li>
                    <li>updateMarginRequirement(): updation for contract margin.</li>
                    <li>updateCollateral(): updation for contract collaterals.</li>
                    <li>updateExpirationDate(): updation for contract expiry times.</li>
                    <li>withdrawTokens()</li>
                    <li>getFee()</li>
                    <li>getCollateralPrice()</li>
                    <li>getCollateralAmount()</li>
                    <li>updateContractCollateral()</li>
                    <li>updateTimeInterval()</li>
                    <li>addCollateral(): add collateral to while list to accepet fo payments.</li>
                    <li>removeCollateral(): remove colllateral from whitelist.</li>
                </ul>
                <h5>>> Security considerations</h5>
                <ul>
                    <li>
                        Used secure automation to update the contract which have expired.
                    </li>
                    <li>
                        Used SafeERC20 library to transfer the ERC20 tokens.
                    </li>
                    <li>
                        Price of the collateral is taken from the chainlink pricefeeds.
                    </li>
                    <li>
                        Updations in the protocol is done through goverence system and owner of the FuturesTradding.sol
                        is Timelock address.
                    </li>
                    <li>
                        Updations are done before the transfering the tokens which helps from "Re-entrany attacks".
                    </li>
                    <li>User can interact with multiple function in a single call using multicall() function. Whichs
                        helps to reduce his gas cost and increases users flexibility.</li>
                    <li>To valid "rounding error" , i have used high precision in calculations.</li>
                    <li>Complex financial operations such as opening, modifying, or closing positions should be
                        optimized for gas efficiency. </li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Perpetuals</h3>
                <p>
                    In decentralized finance (DeFi), perpetual contracts (or "perps") are a type of derivative
                    instrument that allows traders to speculate on the price of an underlying asset (like
                    cryptocurrencies) without owning the asset itself. They are similar to futures contracts but with
                    one key difference: perpetual contracts do not have an expiry date. This means traders can hold
                    their positions indefinitely, as long as they meet the margin requirements. The fees for the opening
                    and closing positions are changed dynamically based on the number of open interest in that
                    particular pool. This helps to maintain the liquidity of the pool and also helps to prevent
                    "front running" attacks.
                </p>
                <h5>>> Key Features</h5>
                <ul>
                    <li>With any two tokens(one for Long and other for short) can create a tradepool by calling
                        createTradePool() function by implementing HookManager contract.</li>
                    <li>To create a pool user have to pay some fees.</li>
                    <li>Stable coins are not alllowed as long token because long tokens should be any volatile
                        tokens(like WBTC, WETH, LINK etc..)</li>
                    <li>Short tokens are any types stable or non-stable tokens.</li>
                    <li>Native Eth is not allowed to create a tradepool.</li>
                    <li>While creating a tradepool, an ERC20 token contract also created. The owner of that ERC20 token
                        is tradepool. Whenever liquidity providers add or remove liquidity we mint that ERC20 tokens
                        shares using ERC-2646 vault concept to the Liquidity providers.</li>
                    <li>If these LP ERC20 tokens are staked in staking pool, they will earn rewards goverence tokens as
                        rewards.</li>
                    <li>STEPS TO OPEN POSITION</li>
                    <ol>
                        <li>To open position select Long(if you thick the price of collateral is increased) or short(if
                            the price of collateral will decreased)</li>
                        <ol>
                            <li>Long position</li>
                            <ul>
                                <li>
                                    Earns a profit if the token's price goes up</li>
                                <li>
                                    Makes a loss if the token's price goes down</li>
                            </ul>
                            <li>
                                Short position</li>
                            <ul>
                                <li>
                                    Earns a profit if the token's price goes down</li>
                                <li>
                                    Makes a loss if the token's price goes up</li>
                            </ul>
                        </ol>
                        <li>Select the type of order, there are mainly 4 types of orders 1)Market Order 2)Price Limit
                            Order 3)Stop Loss Order 4)Time Limit Order</li>
                        <ul>
                            <li><b>Market Order</b>: These order are created instantly at current market price</li>
                            <li><b>Price Limit Order</b>: These orders are placed when the particular given price met.
                                Then only it will open the position automatically using chainlink. If the price was not
                                met then it last for infinite time.</li>
                            <li><b>Stop Loss Order</b>: These orders are created at current market price, but sets a
                                stop loss price. Where the price met then position is closed automatically. For longs
                                the stop loss price should be less than the current price and for shorts the stop loss
                                price should be greater
                                than the current price.</li>
                            <li><b>Time Limit Order</b>: In this order type trade innitially gives the closing time,
                                whatever the position is in, it is closed automatically whne the xepiry time met. It
                                open the position at current market price.</li>
                        </ul>
                        <li>Selecet the collateral you want to trade and slect the collateral you have to pay.</li>
                        <li>Enter the collateral amount you want to pay and selcet the leverage. Protocol shows the
                            respetive size of position based on the fees, open interest, available liquidity in that
                            pool.</li>
                        <li>Check all the fees and margin amount and stike price.Then click place order to open the
                            required position.</li>
                    </ol>
                    <li>For any order the time taken between to open and close position, protocol will take fees. If
                        trader open the position for long time he has to pay fees more.</li>
                    <li>If the total amount in longs is more than the shorts in the pool and new trader want to open
                        position in long then the new trader have to pay funding fee, if he wnat to open short then
                        no need to pay funding fee.</li>
                    <li>NOTE : Funding fee is changed dynamically based on how much differenec between the total
                        amouunt of longs and shorts in pool.</li>
                    <li>Protocol is fixed to open any type of order position(0.03%)</li>
                    <li>All the fees are send to the liquidity providers. Based on the shares the liquidity provider
                        have we give that much of tokens.</li>
                    <li>While closing the position protocol checks the profit/loss the trader get. If he get profit the
                        profits are paid in terms of short collateral if he get loss the amount is subtracted from the
                        payed amount.</li>
                    <li>Chainlink Automation checks all the orders which are in active once in a day, if any position
                        loss is more than they payed. Then the position is closed automatically without permission from
                        owner.</li>
                    <li>Using pool manager also act as bot to validating the positions every time.</li>
                </ul>
                <div>
                    <span id="levelBox">PoolLibrary.sol</span>
                    <pre style="margin: 0px; padding: 0px;">
                        <code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

library PoolLibrary {
    function getLiquidityAmount(uint256 _amount, uint256 _reserves, uint256 _totalSupply)
        internal
        pure
        returns (uint256 liquidity)
    {
        uint256 minLiquidityLock = 1000;

        if (_totalSupply == 0) {
            require(_amount > minLiquidityLock, "Min Liquidity");
            liquidity = _amount - minLiquidityLock;
            // mimimum liquidity is locked perminently
        } else {
            liquidity = (_amount * _totalSupply) / _reserves;
        }
        require(liquidity > 0, "POOL : Invalid mint liquidity");
    }

    function getRemoveLiquidity(uint256 _liquidity, uint256 _reserves, uint256 _totalSupply)
        internal
        pure
        returns (uint256 amount)
    {
        require(_totalSupply != 0, "Invalid total supply");
        amount = (_liquidity * _reserves) / _totalSupply;
    }

    function getProtocolFee(uint256 _amountIn, uint256 _fee) internal pure returns (uint256 amountIn) {
        amountIn = (_amountIn * _fee) / 10000;
    }

    function getFundingFee(
        uint256 _collateral, // token-B
        uint256 _leverage,
        bool _isLong,
        uint256 _longSize,
        uint256 _shortSize,
        uint256 _longCollateral,
        uint256 _shortCollateral,
        uint256 _decimals // decimals-B
    ) internal pure returns (uint256 fundingFee) {
        fundingFee = 0;

        if (_longCollateral > _shortCollateral) {
            if (_isLong) {
                uint256 collateralDifference = _longCollateral - _shortCollateral + _collateral;
                uint256 longRatio = (_longSize * 100) / _longCollateral;
                return (collateralDifference * _leverage * longRatio * _collateral) / 10 ** (_decimals + 10);
            }
        } else if (_longCollateral < _shortCollateral) {
            if (!_isLong) {
                uint256 collateralDifference = _shortCollateral - _longCollateral + _collateral;
                uint256 shortRatio = (_shortSize * 100) / _shortCollateral;
                return (collateralDifference * _leverage * shortRatio * _collateral) / 10 ** (_decimals + 10);
            }
        }
        // for remaining all cases return funding fee = 0
    }

    function getMaintenanceMargin(
        uint256 _collateral,
        uint256 _leverage,
        uint256 _size,
        uint256 _sizeIntokens,
        uint256 _minMargin
    ) internal pure returns (uint256 margin) {
        margin = (_collateral * _minMargin) / 10000;
        uint256 updatedSize = (_size + ((_collateral * _leverage) / 100));
        uint256 ratio = (updatedSize * 10000) / (_sizeIntokens + _collateral);
        uint256 multiplier = (_leverage * 10000) / ratio;
        margin += (_collateral * multiplier) / 100000000;
    }

    function getSize(uint256 _collateral, uint256 _leverage, uint256 _fundingFee, uint256 _protocolFee)
        internal
        pure
        returns (uint256)
    {
        // return in terms of token-B decimals
        uint256 remainingCollateral = _collateral - _fundingFee - _protocolFee;
        return (remainingCollateral * _leverage) / 100;
    }
    /**
     * check leverage at 1x because at that position collateral > size
     */

    function getliquidationPrice(
        uint256 _collateral,
        uint256 _sizeInTokenA,
        uint256 _margin,
        uint256 _priceA,
        uint256 _priceB,
        uint256 _decimalA,
        uint256 _decimalB,
        bool _isLong
    ) internal pure returns (uint256) {
        // liquidation price of token-A
        uint256 remainingCollateral;
        if (_isLong) {
            remainingCollateral = _collateral - _margin;
            uint256 amount = gettokenAAmount(remainingCollateral, _priceA, _priceB, _decimalA, _decimalB);
            amount = (10 ** 8 - (amount * 10 ** 8 / _sizeInTokenA));
            return (_priceA * amount) / 10 ** 8;
        } else {
            remainingCollateral = _collateral + _margin;
            uint256 amount = gettokenAAmount(remainingCollateral, _priceA, _priceB, _decimalA, _decimalB);
            amount = (10 ** 8 + (amount * 10 ** 8 / _sizeInTokenA)); // by 10**8
            return (_priceA * amount) / 10 ** 8; // uisng 10**8 cost more gas for every time function have to find the value of 10**8
        }
    }

    function gettokenAAmount(uint256 _amountB, uint256 _priceA, uint256 _priceB, uint256 _decimalA, uint256 _decimalB)
        internal
        pure
        returns (uint256 amountA)
    {
        amountA = (_amountB * _priceB * 10 ** 8) / _priceA;
        if (_decimalA < _decimalB) {
            amountA = (amountA / 10 ** (_decimalB - _decimalA + 8));
        } else if (_decimalA > _decimalB) {
            amountA = (amountA * 10 ** (_decimalA - _decimalB + 8));
        }
    }

    function getTokeninUSD(uint256 _amount, uint256 _price) internal pure returns (uint256) {
        return (_amount * _price) / 10 ** 8; // returns in usd amount(10**8)
    }

    function getPositionMaintainFee(uint256 _entryTime, uint256 _exitTime, uint256 _feePerSecond)
        internal
        pure
        returns (uint256)
    {
        return (_exitTime - _entryTime) * _feePerSecond; // returns in USD(10**8)
    }

    function getTokenAmountFromUSD(uint256 _amountInUSD, uint256 _price, uint256 _decimals)
        internal
        pure
        returns (uint256)
    {
        return (_amountInUSD * 10 ** _decimals) / _price;
    }
}</code>
                    </pre>
                </div>
                <h5>>> Key Functions</h5>
                <div class="container">
                    <h6>Factory.sol</h6>
                    <ul>
                        <li>createTradePool()</li>
                        <li>getPoolData()</li>
                        <li>computeTradePoolAddress()</li>
                    </ul>
                    <h6>TradePool.sol</h6>
                    <ul>
                        <li>addLiquidity()</li>
                        <li>removeLiquidity()</li>
                        <li>_getPositionData()</li>
                        <li>_checkLiquidityAvailable()</li>
                        <li>openLongPosition()</li>
                        <li>openShortPosition()</li>
                        <li>openPriceLimitPosition()</li>
                        <li>closePosition()</li>
                        <li>_calculatePNL()</li>
                        <Li>changeReceiver()</Li>
                        <li>updatePriceLimitPosition()</li>
                        <li>updateStopLossPosition()</li>
                        <li>updateTimeLimitPosition()</li>
                        <li>updateSize()</li>
                        <li>_liquidatePosition()</li>
                        <li>checkUpkeep()</li>
                        <li>performUpkeep()</li>
                    </ul>
                </div>
                <h5>>> Security considerations</h5>
                <ul>
                    <li>Implement multi-signature wallets or DAO governance for contract upgrades and critical functions
                        to avoid a single point of failure.</li>
                    <li>Timelock controller is the owner of the any pool and the updations in the pool is done through
                        voting mechanism.</li>
                    <li>Carefully manage funding rates and make sure they are updated accurately to prevent gaming of
                        the system. This can help maintain balance between long and short positions.</li>
                    <li>Conduct thorough checks on margin requirements and collateralization to avoid
                        under-collateralized positions. Set minimum margin thresholds and auto-liquidation processes.
                    </li>
                    <li>Consider gas efficiency in smart contract design to ensure that high gas costs do not create
                        vulnerabilities, such as failed liquidations due to exceeding gas limits.</li>
                    <li>To perform multiple actions in a single call multicall is implemented.</li>
                    <li>Mitigate denial-of-service risks by designing contracts to avoid expensive loops or unbounded
                        iterations that can be exploited to exhaust gas limits.</li>
                    <li>Uses chainlink automation to liquiadate the positions to stop losses and pricefeeds to get the
                        price of the collateral.</li>
                    <li>Tokens are transferred only after the state variables are updated.</li>
                </ul>
            </div>

            <div>
                <hr>
                <h3>>> Pool Manager</h3>
                <p>
                    Hooks are a new feature that allows developers to customize the behavior of liquidity pools by
                    attaching smart contract logic to various stages of a trade or liquidity event. This provides
                    unprecedented flexibility and allows for more sophisticated financial applications to be built on
                    top of Trade-Run protocol.
                </p>
                <p>
                    These hooks can be used to modify actions like open or close positions(with different order types),
                    liquidity additions, or removals, allowing developers to program specific rules or reactions to
                    trades. The hooks execute custom code at various points of a pool’s lifecycle, including before or
                    after a trade, which could be used to introduce dynamic fees, on-chain oracles, automatic liquidity
                    management, or even complex financial logic like perpetual futures. It acts like bot to check the
                    data and perform actions required.
                </p>
                <p>List of hooks performed:</p>
                <ul>
                    <li>beforeAddLiquidity()</li>
                    <li>afterAddLiquidity()</li>
                    <li>beforeRemoveLiquidity()</li>
                    <li>afterRemoveLiquidity()</li>
                    <li>beforeOpenPosition() </li>
                    <li>afterOpenPosition()</li>
                    <li>beforeClosePosition()</li>
                    <li>afterClosePosition()</li>
                </ul>
                <p>
                    For a single Hook manager contract, pool creator can create multiple pools with same hook manager
                    contract which helps to controls and maintain the pools stability and flexibilty. These hooks can
                    make communicate with other protocols whileany hook is called. Traders can customize their positions
                    through these hooks, which helps to increse the user experience. Liquidity Providers can add or
                    remove there liquidity based on the open interest and avaliable liquidity in the pools.
                </p>
                <h5>>> Key Features to consider while creating a Hook Manager</h5>
                <ul>
                    <li>Checks-Effects-Interactions Pattern: Always follow the pattern where internal state changes are
                        made before any external interaction. This prevents external contracts from manipulating state
                        during a transaction.</li>
                    <li>Sanitize Inputs: Thoroughly validate all input parameters (e.g., amounts, addresses, asset
                        types) to ensure they are within expected ranges. Invalid inputs can lead to incorrect
                        executions or even contract vulnerabilities.</li>
                    <li>Address Validation: Ensure that only valid, whitelisted addresses can interact with specific
                        functions within the hook manager. This prevents unauthorized contracts or users from invoking
                        sensitive functionality.</li>
                    <li>Access Restrictions: Implement strict access controls to ensure that only authorized entities
                        (e.g., governance contracts or trusted addresses) can modify key parameters of the hook manager
                        or execute sensitive hooks.</li>
                    <li>Limit Interaction Frequency: Apply rate limiting to prevent abuse, such as users or bots
                        repeatedly calling hooks within a short period to manipulate prices, trading volume, or pool
                        balances.</li>
                    <li>Fallback Mechanisms: Implement fallback mechanisms to handle oracle failures, such as switching
                        to a backup oracle or pausing certain actions if the oracle provides invalid data.</li>
                    <li>Avoid Overly Complex Logic: Keep the logic in hooks as simple as possible to reduce the attack
                        surface. Complex logic introduces opportunities for unexpected interactions and edge cases that
                        could be exploited.</li>
                    <li>Anti-Griefing Mechanisms: Add measures that prevent malicious actors from using the liquidation
                        mechanism to constantly liquidate users for small profits, which could harm the user experience
                        and overall trust in the pool.</li>
                    <li>Collateral Checks: Ensure that collateral and margin requirements are correctly enforced at
                        every stage of the trading lifecycle. Incorrect collateral calculations can lead to insolvency
                        risks for the pool.</li>
                    <li>
                        Pool Balance Security: Implement secure balance tracking to avoid cases where liquidity is
                        improperly accounted for, leading to under-collateralized trades or withdrawals.</li>
                </ul>
                <hr>
            </div>
        </div>

        <!-- References -->
        <div class="container">
            <h3>>> Reference</h3>
            <ul>
                <li>
                    <a href="https://eips.ethereum.org/EIPS/eip-4626" target="_blank">EIP 4626</a>
                </li>
                <li>
                    <a href="https://gmx-docs.io/docs/intro/" target="_blank">GMX
                        docs</a>
                </li>
                <li>
                    <a href="https://docs.dydx.exchange/" target="_blank">DYDX docs</a>
                </li>
                <li>
                    <a href="https://www.youtube.com/watch?v=jGC3pGCfYQE&t=3732s" target="_blank">Merkle Airdrops</a>
                </li>
                <li>
                    <a href="https://docs.openzeppelin.com/contracts/5.x/api/governance" target="_blank">Governece
                        Docs</a>
                </li>
            </ul>

        </div>

        <!-- Footer -->
        <footer id="footer">
            <div class="container">
                <div class="copyright">
                    <strong><span>Fund Me</span></strong>
                </div>
                <div class="credits">
                    <a href="#" style="font-size: 10px;">0xd0509B83468409A75De2771C1Ae7bE1026A69927</a>
                </div>
            </div>
        </footer>

        <!-- Scripts imports -->
        <div>
            <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i
                    class="bi bi-arrow-up-short"></i></a>

            <!-- Vendor JS Files -->
            <script src="../assets/vendor/purecounter/purecounter_vanilla.js"></script>
            <script src="../assets/vendor/aos/aos.js"></script>
            <script src="../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
            <script src="../assets/vendor/glightbox/js/glightbox.min.js"></script>
            <script src="../assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
            <script src="../assets/vendor/swiper/swiper-bundle.min.js"></script>
            <script src="../assets/vendor/typed.js/typed.umd.js"></script>
            <script src="../assets/vendor/waypoints/noframework.waypoints.js"></script>
            <script src="../assets/vendor/php-email-form/validate.js"></script>

            <!-- Template Main JS File -->
            <script src="../assets/js/main.js"></script>
        </div>
</body>

</html>